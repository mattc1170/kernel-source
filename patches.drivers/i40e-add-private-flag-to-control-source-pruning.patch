From: Mitch Williams <mitch.a.williams@intel.com>
Date: Tue, 29 Aug 2017 05:32:30 -0400
Subject: i40e: add private flag to control source pruning
Patch-mainline: Queued in subsystem maintainer repository
Git-repo: git://git.kernel.org/pub/scm/linux/kernel/git/davem/net-next.git
Git-commit: 64615b5418bac1d3b3a50a83fb2e42091fe299fe
References: bsc#1034075

By default, our devices do source pruning, that is, they drop receive
packets that have the source MAC matching one of the receive filters.
Unfortunately, this breaks ARP monitoring in channel bonding, as the
bonding driver expects devices to receive ARPs containing their own
source address.

Add an ethtool private flag to control this feature.

Also, remove the netif_running() check when we process our private
flags. It's OK to reset when the device is closed and in most cases we
need the reset the apply these changes.

Signed-off-by: Mitch Williams <mitch.a.williams@intel.com>
Tested-by: Andrew Bowers <andrewx.bowers@intel.com>
Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>
Acked-by: Michal Kubecek <mkubecek@suse.cz>

---
 drivers/net/ethernet/intel/i40e/i40e.h         |  4 +++-
 drivers/net/ethernet/intel/i40e/i40e_ethtool.c | 13 +++++++++++++
 drivers/net/ethernet/intel/i40e/i40e_main.c    | 25 +++++++++++++++++++++++++
 3 files changed, 41 insertions(+), 1 deletion(-)

diff --git a/drivers/net/ethernet/intel/i40e/i40e.h b/drivers/net/ethernet/intel/i40e/i40e.h
index 3e09e653b2e3..970626a6c1f2 100644
--- a/drivers/net/ethernet/intel/i40e/i40e.h
+++ b/drivers/net/ethernet/intel/i40e/i40e.h
@@ -104,7 +104,8 @@
 #define I40E_PRIV_FLAGS_FD_ATR			BIT(2)
 #define I40E_PRIV_FLAGS_VEB_STATS		BIT(3)
 #define I40E_PRIV_FLAGS_HW_ATR_EVICT		BIT(4)
-#define I40E_PRIV_FLAGS_TRUE_PROMISC_SUPPORT	BIT(5)
+#define I40E_PRIV_FLAGS_SOURCE_PRUNING_DISABLED	BIT(5)
+#define I40E_PRIV_FLAGS_TRUE_PROMISC_SUPPORT	BIT(6)
 
 #define I40E_NVM_VERSION_LO_SHIFT	0
 #define I40E_NVM_VERSION_LO_MASK	(0xff << I40E_NVM_VERSION_LO_SHIFT)
@@ -351,6 +352,7 @@ struct i40e_pf {
 #define I40E_FLAG_PTP_L4_CAPABLE		BIT_ULL(53)
 #define I40E_FLAG_WOL_MC_MAGIC_PKT_WAKE		BIT_ULL(54)
 #define I40E_FLAG_TEMP_LINK_POLLING		BIT_ULL(55)
+#define I40E_FLAG_SOURCE_PRUNING_DISABLED	BIT_ULL(59)
 
 	/* tracks features that get auto disabled by errors */
 	u64 auto_disable_flags;
diff --git a/drivers/net/ethernet/intel/i40e/i40e_ethtool.c b/drivers/net/ethernet/intel/i40e/i40e_ethtool.c
index 3aefc9e20439..eb47800346d3 100644
--- a/drivers/net/ethernet/intel/i40e/i40e_ethtool.c
+++ b/drivers/net/ethernet/intel/i40e/i40e_ethtool.c
@@ -234,6 +234,7 @@ static const char i40e_priv_flags_strings[][ETH_GSTRING_LEN] = {
 	"flow-director-atr",
 	"veb-stats",
 	"hw-atr-eviction",
+	"disable-source-pruning",
 };
 
 #define I40E_PRIV_FLAGS_STR_LEN ARRAY_SIZE(i40e_priv_flags_strings)
@@ -3065,6 +3066,8 @@ static u32 i40e_get_priv_flags(struct net_device *dev)
 		ret_flags |= pf->flags & I40E_FLAG_TRUE_PROMISC_SUPPORT ?
 			I40E_PRIV_FLAGS_TRUE_PROMISC_SUPPORT : 0;
 	}
+	ret_flags |= pf->flags & I40E_FLAG_SOURCE_PRUNING_DISABLED ?
+		I40E_PRIV_FLAGS_SOURCE_PRUNING_DISABLED : 0;
 
 	return ret_flags;
 }
@@ -3148,6 +3151,16 @@ static int i40e_set_priv_flags(struct net_device *dev, u32 flags)
 	else
 		pf->auto_disable_flags |= I40E_FLAG_HW_ATR_EVICT_CAPABLE;
 
+	if ((flags & I40E_PRIV_FLAGS_SOURCE_PRUNING_DISABLED) &&
+	    !(pf->flags & I40E_FLAG_SOURCE_PRUNING_DISABLED)) {
+		pf->flags |= I40E_FLAG_SOURCE_PRUNING_DISABLED;
+		reset_required = true;
+	} else if (!(flags & I40E_PRIV_FLAGS_SOURCE_PRUNING_DISABLED) &&
+		   (pf->flags & I40E_FLAG_SOURCE_PRUNING_DISABLED)) {
+		pf->flags &= ~I40E_FLAG_SOURCE_PRUNING_DISABLED;
+		reset_required = true;
+	}
+
 	/* if needed, issue reset to cause things to take effect */
 	if (reset_required)
 		i40e_do_reset(pf, BIT(__I40E_PF_RESET_REQUESTED));
diff --git a/drivers/net/ethernet/intel/i40e/i40e_main.c b/drivers/net/ethernet/intel/i40e/i40e_main.c
index d6aec8214111..26dce1b1f727 100644
--- a/drivers/net/ethernet/intel/i40e/i40e_main.c
+++ b/drivers/net/ethernet/intel/i40e/i40e_main.c
@@ -9673,6 +9673,31 @@ static int i40e_add_vsi(struct i40e_vsi *vsi)
 
 		enabled_tc = i40e_pf_get_tc_map(pf);
 
+		/* Source pruning is enabled by default, so the flag is
+		 * negative logic - if it's set, we need to fiddle with
+		 * the VSI to disable source pruning.
+		 */
+		if (pf->flags & I40E_FLAG_SOURCE_PRUNING_DISABLED) {
+			memset(&ctxt, 0, sizeof(ctxt));
+			ctxt.seid = pf->main_vsi_seid;
+			ctxt.pf_num = pf->hw.pf_id;
+			ctxt.vf_num = 0;
+			ctxt.info.valid_sections |=
+				     cpu_to_le16(I40E_AQ_VSI_PROP_SWITCH_VALID);
+			ctxt.info.switch_id =
+				   cpu_to_le16(I40E_AQ_VSI_SW_ID_FLAG_LOCAL_LB);
+			ret = i40e_aq_update_vsi_params(hw, &ctxt, NULL);
+			if (ret) {
+				dev_info(&pf->pdev->dev,
+					 "update vsi failed, err %s aq_err %s\n",
+					 i40e_stat_str(&pf->hw, ret),
+					 i40e_aq_str(&pf->hw,
+						     pf->hw.aq.asq_last_status));
+				ret = -ENOENT;
+				goto err;
+			}
+		}
+
 		/* MFP mode setup queue map and update VSI */
 		if ((pf->flags & I40E_FLAG_MFP_ENABLED) &&
 		    !(pf->hw.func_caps.iscsi)) { /* NIC type PF */
-- 
2.14.2


From: Jacob Keller <jacob.e.keller@intel.com>
Date: Mon, 6 Feb 2017 14:38:38 -0800
Subject: i40e: send correct port number to AdminQ when enabling UDP tunnels
Patch-mainline: v4.12-rc1
Git-commit: fe0b0cd97b4f210ecd1693edba6eec10820e11f2
References: bsc#1024346 FATE#321239 bsc#1024373 FATE#321247

The firmware expects the port numbers for offloaded UDP tunnels in
Little Endian format. We accidentally sent the value in Big Endian
format which obviously will cause the wrong port number to be put into
the UDP tunnels list. This results in VxLAN and Geneve tunnel Rx
offloads being essentially disabled, unless the port number happens to
be identical after byte swapping. Note that i40e_aq_add_udp_tunnel()
will byteswap the parameter from host order into Little Endian so we
don't need worry about passing strictly a __le16 value to the command.

This patch essentially reverts b3f5c7bc88ba ("i40e: Fix for extra byte
swap in tunnel setup", 2016-08-24), but in a way that makes the result
much more clear to the reader.

Fixes: b3f5c7bc88ba ("i40e: Fix for extra byte swap in tunnel setup", 2016-08-24)
Signed-off-by: Jacob Keller <jacob.e.keller@intel.com>
Reviewed-by: Williams, Mitch A <mitch.a.williams@intel.com>
Tested-by: Andrew Bowers <andrewx.bowers@intel.com>
Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>
[ Adjusted for absent commit
06a5f7f167c5 i40e: Move all UDP port notifiers to single function (v4.8-rc1) ]
Acked-by: David Chang <dchang@suse.com>
---
 drivers/net/ethernet/intel/i40e/i40e.h      |    3 ++-
 drivers/net/ethernet/intel/i40e/i40e_main.c |   28 ++++++++++++++--------------
 2 files changed, 16 insertions(+), 15 deletions(-)

--- a/drivers/net/ethernet/intel/i40e/i40e.h
+++ b/drivers/net/ethernet/intel/i40e/i40e.h
@@ -244,7 +244,8 @@ struct i40e_tc_configuration {
 };
 
 struct i40e_udp_port_config {
-	__be16 index;
+	/* AdminQ command interface expects port number in Host byte order */
+	u16 index;
 	u8 type;
 };
 
--- a/drivers/net/ethernet/intel/i40e/i40e_main.c
+++ b/drivers/net/ethernet/intel/i40e/i40e_main.c
@@ -7372,7 +7372,7 @@ static void i40e_sync_udp_filters_subtas
 #if IS_ENABLED(CONFIG_VXLAN) || IS_ENABLED(CONFIG_GENEVE)
 	struct i40e_hw *hw = &pf->hw;
 	i40e_status ret;
-	__be16 port;
+	u16 port;
 	int i;
 
 	if (!(pf->flags & I40E_FLAG_UDP_FILTER_SYNC))
@@ -7396,7 +7396,7 @@ static void i40e_sync_udp_filters_subtas
 					"%s %s port %d, index %d failed, err %s aq_err %s\n",
 					pf->udp_ports[i].type ? "vxlan" : "geneve",
 					port ? "add" : "delete",
-					ntohs(port), i,
+					port, i,
 					i40e_stat_str(&pf->hw, ret),
 					i40e_aq_str(&pf->hw,
 						    pf->hw.aq.asq_last_status));
@@ -9005,7 +9005,7 @@ static int i40e_set_features(struct net_
  *
  * Returns the index number or I40E_MAX_PF_UDP_OFFLOAD_PORTS if port not found
  **/
-static u8 i40e_get_udp_port_idx(struct i40e_pf *pf, __be16 port)
+static u8 i40e_get_udp_port_idx(struct i40e_pf *pf, u16 port)
 {
 	u8 i;
 
@@ -9027,7 +9027,7 @@ static u8 i40e_get_udp_port_idx(struct i
  * @port: New UDP port number that VXLAN started listening to
  **/
 static void i40e_add_vxlan_port(struct net_device *netdev,
-				sa_family_t sa_family, __be16 port)
+				sa_family_t sa_family, u16 port)
 {
 	struct i40e_netdev_priv *np = netdev_priv(netdev);
 	struct i40e_vsi *vsi = np->vsi;
@@ -9035,7 +9035,7 @@ static void i40e_add_vxlan_port(struct n
 	u8 next_idx;
 	u8 idx;
 
-	idx = i40e_get_udp_port_idx(pf, port);
+	idx = i40e_get_udp_port_idx(pf, ntohs(port));
 
 	/* Check if port already exists */
 	if (idx < I40E_MAX_PF_UDP_OFFLOAD_PORTS) {
@@ -9054,7 +9054,7 @@ static void i40e_add_vxlan_port(struct n
 	}
 
 	/* New port: add it and mark its index in the bitmap */
-	pf->udp_ports[next_idx].index = port;
+	pf->udp_ports[next_idx].index = ntohs(port);
 	pf->udp_ports[next_idx].type = I40E_AQC_TUNNEL_TYPE_VXLAN;
 	pf->pending_udp_bitmap |= BIT_ULL(next_idx);
 	pf->flags |= I40E_FLAG_UDP_FILTER_SYNC;
@@ -9067,14 +9067,14 @@ static void i40e_add_vxlan_port(struct n
  * @port: UDP port number that VXLAN stopped listening to
  **/
 static void i40e_del_vxlan_port(struct net_device *netdev,
-				sa_family_t sa_family, __be16 port)
+				sa_family_t sa_family, u16 port)
 {
 	struct i40e_netdev_priv *np = netdev_priv(netdev);
 	struct i40e_vsi *vsi = np->vsi;
 	struct i40e_pf *pf = vsi->back;
 	u8 idx;
 
-	idx = i40e_get_udp_port_idx(pf, port);
+	idx = i40e_get_udp_port_idx(pf, ntohs(port));
 
 	/* Check if port already exists */
 	if (idx < I40E_MAX_PF_UDP_OFFLOAD_PORTS) {
@@ -9099,7 +9099,7 @@ static void i40e_del_vxlan_port(struct n
  * @port: New UDP port number that GENEVE started listening to
  **/
 static void i40e_add_geneve_port(struct net_device *netdev,
-				 sa_family_t sa_family, __be16 port)
+				 sa_family_t sa_family, u16 port)
 {
 	struct i40e_netdev_priv *np = netdev_priv(netdev);
 	struct i40e_vsi *vsi = np->vsi;
@@ -9110,7 +9110,7 @@ static void i40e_add_geneve_port(struct
 	if (!(pf->flags & I40E_FLAG_GENEVE_OFFLOAD_CAPABLE))
 		return;
 
-	idx = i40e_get_udp_port_idx(pf, port);
+	idx = i40e_get_udp_port_idx(pf, ntohs(port));
 
 	/* Check if port already exists */
 	if (idx < I40E_MAX_PF_UDP_OFFLOAD_PORTS) {
@@ -9129,12 +9129,12 @@ static void i40e_add_geneve_port(struct
 	}
 
 	/* New port: add it and mark its index in the bitmap */
-	pf->udp_ports[next_idx].index = port;
+	pf->udp_ports[next_idx].index = ntohs(port);
 	pf->udp_ports[next_idx].type = I40E_AQC_TUNNEL_TYPE_NGE;
 	pf->pending_udp_bitmap |= BIT_ULL(next_idx);
 	pf->flags |= I40E_FLAG_UDP_FILTER_SYNC;
 
-	dev_info(&pf->pdev->dev, "adding geneve port %d\n", ntohs(port));
+	dev_info(&pf->pdev->dev, "adding geneve(port %d\n", ntohs(port));
 }
 
 /**
@@ -9144,7 +9144,7 @@ static void i40e_add_geneve_port(struct
  * @port: UDP port number that GENEVE stopped listening to
  **/
 static void i40e_del_geneve_port(struct net_device *netdev,
-				 sa_family_t sa_family, __be16 port)
+				 sa_family_t sa_family, u16 port)
 {
 	struct i40e_netdev_priv *np = netdev_priv(netdev);
 	struct i40e_vsi *vsi = np->vsi;
@@ -9154,7 +9154,7 @@ static void i40e_del_geneve_port(struct
 	if (!(pf->flags & I40E_FLAG_GENEVE_OFFLOAD_CAPABLE))
 		return;
 
-	idx = i40e_get_udp_port_idx(pf, port);
+	idx = i40e_get_udp_port_idx(pf, ntohs(port));
 
 	/* Check if port already exists */
 	if (idx < I40E_MAX_PF_UDP_OFFLOAD_PORTS) {

From 6015556d5f9bd78ea76c1978d68d9768bf857f29 Mon Sep 17 00:00:00 2001
From: Peter Antoine <peter.antoine@intel.com>
Date: Wed, 28 Oct 2015 14:04:30 -0700
Subject: [PATCH 082/143] [VPG]: i915: dump_lrc extend dump size to include MOCS

This patch extends the amount of data that is dumped from the context.
The MOCS values are quite low in the context so it needs to dump more
information so that it can be seen.

To reduce the amount of data being output the dump now removes repeated
zeros to try and reduce the dump size (it helps when other contexts and
not only the render context are in use).

Tracked-On:
For: GMINL-13168
Change-Id: I97e0ead4ee2b23788bb2d0fd5ba8e07ecab8c727
Signed-off-by: Peter Antoine <peter.antoine@intel.com>
Signed-off-by: Jeff McGee <jeff.mcgee@intel.com>
Signed-off-by: Matt Roper <matthew.d.roper@intel.com>

Conflicts:
	drivers/gpu/drm/i915/i915_debugfs.c
---
 drivers/gpu/drm/i915/i915_debugfs.c |   48 +++++++++++++++++++++++++++++++---
 1 files changed, 43 insertions(+), 5 deletions(-)

diff --git a/drivers/gpu/drm/i915/i915_debugfs.c b/drivers/gpu/drm/i915/i915_debugfs.c
index 179b25d..7f59629 100644
--- a/drivers/gpu/drm/i915/i915_debugfs.c
+++ b/drivers/gpu/drm/i915/i915_debugfs.c
@@ -2175,6 +2175,8 @@ static void i915_dump_lrc_obj(struct seq_file *m,
 	uint32_t *reg_state;
 	int j;
 	struct drm_i915_gem_object *ctx_obj = ctx->engine[ring->id].state;
+	int zeros_start = 0;
+	int zeros_length = 0;
 	unsigned long ggtt_offset = 0;
 
 	if (ctx_obj == NULL) {
@@ -2200,12 +2202,48 @@ static void i915_dump_lrc_obj(struct seq_file *m,
 	if (!WARN_ON(page == NULL)) {
 		reg_state = kmap_atomic(page);
 
-		for (j = 0; j < 0x600 / sizeof(u32) / 4; j += 4) {
-			seq_printf(m, "\t[0x%08lx] 0x%08x 0x%08x 0x%08x 0x%08x\n",
-				   ggtt_offset + 4096 + (j * 4),
-				   reg_state[j], reg_state[j + 1],
-				   reg_state[j + 2], reg_state[j + 3]);
+		for (j = 0; j < (PAGE_SIZE * 4) / sizeof(u32) / 4; j += 4) {
+			/* ZERO removal - make the listing smaller */
+			if (reg_state[j] == 0 &&
+			    reg_state[j+1] == 0 &&
+			    reg_state[j+2] == 0 &&
+			    reg_state[j+3] == 0) {
+				/* Only zeros found - count and skip output */
+				if (zeros_length == 0)
+					zeros_start = j;
+
+				zeros_length += 4;
+
+			} else if (zeros_length > 0) {
+				/* non-zeros found after zeros */
+				seq_printf(m, "\t[0x%08lx] %d zeros skipped\n",
+				   ggtt_offset + 4096 + (zeros_start * 4),
+				   zeros_length);
+
+				seq_printf(m,
+				  "\t[0x%08lx] 0x%08x 0x%08x 0x%08x 0x%08x\n",
+				  ggtt_offset + 4096 + (j * 4),
+				  reg_state[j], reg_state[j + 1],
+				  reg_state[j + 2], reg_state[j + 3]);
+
+				zeros_length = 0;
+			} else {
+				/* non-zeros on line output it */
+				seq_printf(m,
+				"\t[0x%08lx] 0x%08x 0x%08x 0x%08x 0x%08x\n",
+					   ggtt_offset + 4096 + (j * 4),
+					   reg_state[j], reg_state[j + 1],
+					   reg_state[j + 2], reg_state[j + 3]);
+			}
 		}
+
+		if (zeros_length > 0) {
+			seq_printf(m, "\t[0x%08lx] %d zeros skipped\n",
+			ggtt_offset + 4096 + (zeros_start * 4),
+			zeros_length);
+			zeros_length = 0;
+		}
+
 		kunmap_atomic(reg_state);
 	}
 
-- 
1.7.1


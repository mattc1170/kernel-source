From 3a76246702aebea35b3abf88b5a3a11c7807706d Mon Sep 17 00:00:00 2001
From: Zhipeng Gong <zhipeng.gong@intel.com>
Date: Thu, 14 Apr 2016 11:25:47 -0400
Subject: [PATCH 114/143] [VPG]: drm/i915: add mvp support

Add mvp support for performance tracing.
---
 drivers/gpu/drm/i915/Makefile              |    3 +
 drivers/gpu/drm/i915/i915_debugfs.c        |   30 ++++-
 drivers/gpu/drm/i915/i915_drv.h            |    3 +
 drivers/gpu/drm/i915/i915_gem.c            |    1 +
 drivers/gpu/drm/i915/i915_gem_execbuffer.c |    4 +-
 drivers/gpu/drm/i915/i915_mvp.c            |  229 ++++++++++++++++++++++++++++
 drivers/gpu/drm/i915/i915_mvp.h            |   55 +++++++
 drivers/gpu/drm/i915/intel_lrc.c           |    2 +
 8 files changed, 325 insertions(+), 2 deletions(-)
 create mode 100644 drivers/gpu/drm/i915/i915_mvp.c
 create mode 100644 drivers/gpu/drm/i915/i915_mvp.h

diff --git a/drivers/gpu/drm/i915/Makefile b/drivers/gpu/drm/i915/Makefile
index 0f82b55..01a8a2a 100644
--- a/drivers/gpu/drm/i915/Makefile
+++ b/drivers/gpu/drm/i915/Makefile
@@ -101,6 +101,9 @@ i915-y += i915_vgpu.o
 # legacy horrors
 i915-y += i915_dma.o
 
+# mvp
+i915-y += i915_mvp.o
+
 obj-$(CONFIG_DRM_I915)  += i915.o
 
 CFLAGS_i915_trace_points.o := -I$(src)
diff --git a/drivers/gpu/drm/i915/i915_debugfs.c b/drivers/gpu/drm/i915/i915_debugfs.c
index 40cf87c..5ba83fe 100644
--- a/drivers/gpu/drm/i915/i915_debugfs.c
+++ b/drivers/gpu/drm/i915/i915_debugfs.c
@@ -5547,6 +5547,33 @@ static int i915_sseu_status(struct seq_file *m, void *unused)
 	return 0;
 }
 
+static int
+i915_mvp_enable_get(void *data, u64 *val)
+{
+	*val = (u64) i915_mvp_is_enabled();
+	return 0;
+}
+
+static int
+i915_mvp_enable_set(void *data, u64 val)
+{
+	struct drm_device *dev = data;
+	int ret;
+
+	ret = mutex_lock_interruptible(&dev->struct_mutex);
+	if (ret)
+		return ret;
+
+	ret = i915_mvp_enable(dev, (bool)val);
+	mutex_unlock(&dev->struct_mutex);
+	return ret;
+}
+
+DEFINE_SIMPLE_ATTRIBUTE(i915_mvp_enable_fops,
+			i915_mvp_enable_get,
+			i915_mvp_enable_set,
+			"%lld\n");
+
 static int i915_forcewake_open(struct inode *inode, struct file *file)
 {
 	struct drm_device *dev = inode->i_private;
@@ -5700,7 +5727,8 @@ static const struct i915_debugfs_files {
 	{"i915_fbc_false_color", &i915_fbc_fc_fops},
 	{"i915_dp_test_data", &i915_displayport_test_data_fops},
 	{"i915_dp_test_type", &i915_displayport_test_type_fops},
-	{"i915_dp_test_active", &i915_displayport_test_active_fops}
+	{"i915_dp_test_active", &i915_displayport_test_active_fops},
+	{"i915_mvp_enable", &i915_mvp_enable_fops}
 };
 
 void intel_display_crc_init(struct drm_device *dev)
diff --git a/drivers/gpu/drm/i915/i915_drv.h b/drivers/gpu/drm/i915/i915_drv.h
index f5ae8d1..230c142 100644
--- a/drivers/gpu/drm/i915/i915_drv.h
+++ b/drivers/gpu/drm/i915/i915_drv.h
@@ -53,6 +53,7 @@
 #include "intel_guc.h"
 #include <linux/fence.h>
 
+#include "i915_mvp.h"
 #include  "i915_perfmon_defs.h"
 
 /* General customization:
@@ -2374,6 +2375,8 @@ struct drm_i915_gem_request {
 
 	struct hlist_node ctx_link;
 	uint32_t dep_uniq;
+
+	struct i915_mvp_req_record mvp_req;
 };
 
 int i915_gem_request_alloc(struct intel_engine_cs *ring,
diff --git a/drivers/gpu/drm/i915/i915_gem.c b/drivers/gpu/drm/i915/i915_gem.c
index 896d5c2..31f3e6f 100644
--- a/drivers/gpu/drm/i915/i915_gem.c
+++ b/drivers/gpu/drm/i915/i915_gem.c
@@ -1521,6 +1521,7 @@ static void i915_gem_request_retire(struct drm_i915_gem_request *request)
 
 	list_del_init(&request->list);
 	i915_gem_request_remove_from_client(request);
+	i915_mvp_read_req(request);
 
 	/*
 	 * In case the request is still in the signal pending list,
diff --git a/drivers/gpu/drm/i915/i915_gem_execbuffer.c b/drivers/gpu/drm/i915/i915_gem_execbuffer.c
index 78dba05..b06e0bd 100644
--- a/drivers/gpu/drm/i915/i915_gem_execbuffer.c
+++ b/drivers/gpu/drm/i915/i915_gem_execbuffer.c
@@ -973,7 +973,8 @@ i915_gem_check_execbuffer(struct drm_i915_gem_execbuffer2 *exec)
 		DRM_DEBUG("UXA submitting garbage DR4, fixing up\n");
 		exec->DR4 = 0;
 	}
-	if (exec->DR1 || exec->DR4)
+
+	if (exec->DR1)
 		return false;
 
 	if ((exec->batch_start_offset | exec->batch_len) & 0x7)
@@ -1748,6 +1749,7 @@ i915_gem_do_execbuffer(struct drm_device *dev, void *data,
 	params->args_DR1                = args->DR1;
 	params->args_DR4                = args->DR4;
 	params->batch_obj               = batch_obj;
+	i915_mvp_init_req(params->request, args->DR4);
 
 	/* Start with the context's priority level */
 	qe.priority = ctx->sched_info.priority;
diff --git a/drivers/gpu/drm/i915/i915_mvp.c b/drivers/gpu/drm/i915/i915_mvp.c
new file mode 100644
index 0000000..fd1b8b2
--- /dev/null
+++ b/drivers/gpu/drm/i915/i915_mvp.c
@@ -0,0 +1,229 @@
+/*
+ * Copyright  2016 Intel Corporation
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+ * IN THE SOFTWARE.
+ *
+ * Authors:
+ *	Jabin Wu <jabin.wu@intel.com>
+ */
+
+#include <linux/kernel.h>
+#include <drm/drm.h>
+#include "i915_drv.h"
+
+struct i915_mvp_info {
+	struct drm_i915_gem_object *buf_obj;
+	int buf_offset;
+	u64 ggtt_offset;
+	char __iomem *cpu_addr;
+	bool enabled;
+};
+struct i915_mvp_info i915_mvp;
+
+#define CIRCLE_BUF_SIZE (256 * PAGE_SIZE)
+#define MVP_GEN6_MI_PIPE_CONTROL_TIMESTAMP  (0x03 << 14)
+#define MVP_GEN6_MI_FLUSH_DW_TIMESTAMP      (0x03 << 14)
+#define MVP_END_TIME_OFFSET 8
+
+static int i915_mvp_init(struct drm_device *dev)
+{
+	int ret;
+	struct drm_i915_private *dev_priv = dev->dev_private;
+
+	i915_mvp.buf_obj = i915_gem_alloc_object(dev, CIRCLE_BUF_SIZE);
+	if (i915_mvp.buf_obj == NULL) {
+		DRM_ERROR("Failed to allocate mvp bo\n");
+		return -ENOMEM;
+	}
+
+	ret = i915_gem_obj_ggtt_pin(i915_mvp.buf_obj, PAGE_SIZE, PIN_MAPPABLE);
+	if (ret) {
+		DRM_ERROR("Failed to pin mvp bo\n");
+		goto err_unref;
+	}
+
+	i915_mvp.ggtt_offset = i915_gem_obj_ggtt_offset(i915_mvp.buf_obj);
+	i915_mvp.cpu_addr =
+	    ioremap_wc(dev_priv->gtt.mappable_base +
+		       i915_gem_obj_ggtt_offset(i915_mvp.buf_obj),
+		       CIRCLE_BUF_SIZE);
+	if (i915_mvp.cpu_addr == NULL) {
+		DRM_ERROR("Failed to pin mvp bo\n");
+		ret = -ENOSPC;
+		goto err_unpin;
+	}
+
+	i915_mvp.enabled = true;
+	i915_mvp.buf_offset = 0;
+
+	return 0;
+
+ err_unpin:
+	i915_gem_object_ggtt_unpin(i915_mvp.buf_obj);
+ err_unref:
+	drm_gem_object_unreference(&i915_mvp.buf_obj->base);
+	return ret;
+}
+
+static int i915_mvp_exit(void)
+{
+	i915_gem_free_object(&i915_mvp.buf_obj->base);
+	iounmap(i915_mvp.cpu_addr);
+	i915_mvp.buf_obj = NULL;
+	i915_mvp.cpu_addr = NULL;
+	i915_mvp.ggtt_offset = 0;
+	i915_mvp.enabled = false;
+	i915_mvp.buf_offset = 0;
+	return 0;
+}
+
+static void i915_mvp_get_buf_space(struct drm_i915_gem_request *req)
+{
+	if (i915_mvp.buf_offset + sizeof(struct i915_mvp_buf_record) >= CIRCLE_BUF_SIZE) {
+		i915_mvp.buf_offset = 0;
+	}
+	req->mvp_req.cpu_addr =
+	    (struct i915_mvp_buf_record *)(i915_mvp.cpu_addr + i915_mvp.buf_offset);
+	req->mvp_req.gpu_addr = i915_mvp.ggtt_offset + i915_mvp.buf_offset;
+	i915_mvp.buf_offset += sizeof(struct i915_mvp_buf_record);
+}
+
+static void i915_mvp_mi_pipe_control(struct intel_engine_cs *ring,
+				     struct drm_i915_gem_request *req,
+				     u_int32_t addr)
+{
+	int ret;
+	struct intel_ringbuffer *ringbuf = req->ringbuf;
+
+	ret = intel_logical_ring_begin(req, 6);
+	if (ret)
+		return;
+	intel_logical_ring_emit(ringbuf, GFX_OP_PIPE_CONTROL(6));
+	intel_logical_ring_emit(ringbuf,
+				MVP_GEN6_MI_PIPE_CONTROL_TIMESTAMP |
+				PIPE_CONTROL_GLOBAL_GTT_IVB);
+	intel_logical_ring_emit(ringbuf, addr);
+	intel_logical_ring_emit(ringbuf, 0);
+	intel_logical_ring_emit(ringbuf, 0);
+	intel_logical_ring_emit(ringbuf, 0);
+	intel_logical_ring_advance(ringbuf);
+}
+
+static void i915_mvp_mi_flush_dw(struct intel_engine_cs *ring,
+				 struct drm_i915_gem_request *req,
+				 u_int32_t addr)
+{
+	int ret;
+	struct intel_ringbuffer *ringbuf = req->ringbuf;
+
+	ret = intel_logical_ring_begin(req, 6);
+	if (ret)
+		return;
+	intel_logical_ring_emit(ringbuf,
+				(MI_FLUSH_DW + 2) | MVP_GEN6_MI_FLUSH_DW_TIMESTAMP);
+	intel_logical_ring_emit(ringbuf,
+				((addr & 0xFFFFFFF8) | MI_FLUSH_DW_USE_GTT));
+	intel_logical_ring_emit(ringbuf, 0);
+	intel_logical_ring_emit(ringbuf, 0);
+	intel_logical_ring_emit(ringbuf, 0);
+	intel_logical_ring_emit(ringbuf, 0);
+	intel_logical_ring_advance(ringbuf);
+
+}
+
+void i915_mvp_init_req(struct drm_i915_gem_request *req, u32 perf_tag)
+{
+	if (!i915_mvp.enabled)
+		return;
+	req->mvp_req.perf_tag = perf_tag;
+	req->mvp_req.pid = current->pid;
+	req->mvp_req.cpu_addr = NULL;
+}
+
+void i915_mvp_read_req(struct drm_i915_gem_request *req)
+{
+	if (i915_mvp.enabled && req->mvp_req.cpu_addr != NULL)
+		trace_printk("pid=%d tag=%x uniq=%u seqno=%u ring=%d cpu_time=%llx gpu_time=%llx start=%llx end=%llx\n",
+		     		req->mvp_req.pid, req->mvp_req.perf_tag, req->uniq, req->seqno,
+		     		req->ring->id, req->mvp_req.cpu_time, req->mvp_req.gpu_time,
+		     		req->mvp_req.cpu_addr->start_time,
+		     		req->mvp_req.cpu_addr->end_time);
+}
+
+int i915_mvp_start_task(struct drm_device *dev,
+			struct intel_engine_cs *ring,
+			struct drm_i915_gem_request *req)
+{
+	struct drm_i915_private *dev_priv = dev->dev_private;
+	u_int64_t gtime, ctime;
+	int this_cpu;
+
+	if (!i915_mvp.enabled)
+		return 0;
+
+	WARN_ON(!mutex_is_locked(&dev->struct_mutex));
+
+	this_cpu = raw_smp_processor_id();
+	ctime = cpu_clock(this_cpu);
+	gtime = I915_READ(RING_TIMESTAMP(ring->mmio_base));
+
+	i915_mvp_get_buf_space(req);
+	req->mvp_req.cpu_time = ctime;
+	req->mvp_req.gpu_time = gtime;
+
+	if (ring->id == RCS)
+		i915_mvp_mi_pipe_control(ring, req, req->mvp_req.gpu_addr);
+	else
+		i915_mvp_mi_flush_dw(ring, req, req->mvp_req.gpu_addr);
+	return 0;
+}
+
+int i915_mvp_end_task(struct drm_device *dev,
+		      struct intel_engine_cs *ring,
+		      struct drm_i915_gem_request *req)
+{
+	if (!i915_mvp.enabled)
+		return 0;
+
+	WARN_ON(!mutex_is_locked(&dev->struct_mutex));
+
+	if (ring->id == RCS)
+		i915_mvp_mi_pipe_control(ring, req, req->mvp_req.gpu_addr +
+					MVP_END_TIME_OFFSET);
+	else
+		i915_mvp_mi_flush_dw(ring, req, req->mvp_req.gpu_addr +
+					MVP_END_TIME_OFFSET);
+
+	return 0;
+}
+
+bool i915_mvp_is_enabled(void)
+{
+	return i915_mvp.enabled;
+}
+
+int i915_mvp_enable(struct drm_device *dev, bool enable)
+{
+	if (!i915_mvp.enabled && enable)
+		return i915_mvp_init(dev);
+	if (i915_mvp.enabled && !enable)
+		return i915_mvp_exit();
+	return 0;
+}
diff --git a/drivers/gpu/drm/i915/i915_mvp.h b/drivers/gpu/drm/i915/i915_mvp.h
new file mode 100644
index 0000000..1e996b9
--- /dev/null
+++ b/drivers/gpu/drm/i915/i915_mvp.h
@@ -0,0 +1,55 @@
+/*
+ * Copyright  2016 Intel Corporation
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+ * IN THE SOFTWARE.
+ */
+
+#ifndef _I915_MVP_H_
+#define _I915_MVP_H_
+
+struct i915_mvp_buf_record {
+	u64 start_time;
+	u64 end_time;
+};
+
+struct i915_mvp_req_record {
+	u64 cpu_time;
+	u64 gpu_time;
+	pid_t pid;
+	u32 perf_tag;
+	struct i915_mvp_buf_record *cpu_addr;
+	u64 gpu_addr;
+};
+
+bool i915_mvp_is_enabled(void);
+
+int i915_mvp_enable(struct drm_device *dev, bool enable);
+
+int i915_mvp_start_task(struct drm_device *dev, struct intel_engine_cs *ring,
+			struct drm_i915_gem_request *req);
+
+int i915_mvp_end_task(struct drm_device *dev, struct intel_engine_cs *ring,
+		      struct drm_i915_gem_request *req);
+
+void i915_mvp_init_req(struct drm_i915_gem_request *req, u32 perf_tag);
+
+void i915_mvp_read_req(struct drm_i915_gem_request *req);
+
+#endif
diff --git a/drivers/gpu/drm/i915/intel_lrc.c b/drivers/gpu/drm/i915/intel_lrc.c
index f8a2931..6c9fd9e 100644
--- a/drivers/gpu/drm/i915/intel_lrc.c
+++ b/drivers/gpu/drm/i915/intel_lrc.c
@@ -1097,7 +1097,9 @@ int intel_execlists_submission_final(struct i915_execbuffer_params *params)
 	exec_start = params->batch_obj_vm_offset +
 		     params->args_batch_start_offset;
 
+	i915_mvp_start_task(dev, ring, req);
 	ret = ring->emit_bb_start(req, exec_start, params->dispatch_flags);
+	i915_mvp_end_task(dev, ring, req);
 	if (ret)
 		goto err;
 
-- 
1.7.1


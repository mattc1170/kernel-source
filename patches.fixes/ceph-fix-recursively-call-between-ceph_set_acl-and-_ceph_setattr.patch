From: "Yan, Zheng" <zyan@redhat.com>
Date: Wed, 19 Apr 2017 10:01:48 +0800
Subject: ceph: fix recursively call between ceph_set_acl and __ceph_setattr
Patch-mainline: Queued in subsystem maintainer repository
Git-repo: git://github.com/ceph/ceph-client
Git-commit: d0c596a05eda3039e0c41a7c0641cdd190a80509
References: bsc#1034902

ceph_set_acl() calls __ceph_setattr() if the setacl operation needs
to modify inode's i_mode. __ceph_setattr() updates inode's i_mode,
then calls posix_acl_chmod().

The problem is that __ceph_setattr() calls posix_acl_chmod() before
sending the setattr request. The get_acl() call in posix_acl_chmod()
can trigger a getxattr request. The reply of the getxattr request
can restore inode's i_mode to its old value. The set_acl() call in
posix_acl_chmod() sees old value of inode's i_mode, so it calls
__ceph_setattr() again.

Link: http://tracker.ceph.com/issues/19688
Reported-by: Jerry Lee <leisurelysw24@gmail.com>
Tested-by: Luis Henriques <lhenriques@suse.com>
Reviewed-by: Jeff Layton <jlayton@redhat.com>
Signed-off-by: "Yan, Zheng" <zyan@redhat.com>
Acked-by: Luis Henriques <lhenriques@suse.com>
[luis: __ceph_setattr doesn't exist, implement all the changes directly in
 ceph_setattr.  The wrapper function was introduced only in upstream
 commit a26feccaba29 ("ceph: Get rid of d_find_alias in ceph_set_acl").]
---
 fs/ceph/inode.c |   18 +++++++-----------
 1 file changed, 7 insertions(+), 11 deletions(-)

--- a/fs/ceph/inode.c
+++ b/fs/ceph/inode.c
@@ -1985,11 +1985,6 @@ int ceph_setattr(struct dentry *dentry,
 	if (inode_dirty_flags)
 		__mark_inode_dirty(inode, inode_dirty_flags);
 
-	if (ia_valid & ATTR_MODE) {
-		err = posix_acl_chmod(inode, attr->ia_mode);
-		if (err)
-			goto out_put;
-	}
 
 	if (mask) {
 		req->r_inode = inode;
@@ -2003,13 +1998,14 @@ int ceph_setattr(struct dentry *dentry,
 	     ceph_cap_string(dirtied), mask);
 
 	ceph_mdsc_put_request(req);
-	if (mask & CEPH_SETATTR_SIZE)
-		__ceph_do_pending_vmtruncate(inode);
-	ceph_free_cap_flush(prealloc_cf);
-	return err;
-out_put:
-	ceph_mdsc_put_request(req);
 	ceph_free_cap_flush(prealloc_cf);
+
+	if (err >= 0 && (mask & CEPH_SETATTR_SIZE))
+		__ceph_do_pending_vmtruncate(inode);
+
+	if (err >= 0 && (attr->ia_valid & ATTR_MODE))
+		err = posix_acl_chmod(inode, attr->ia_mode);
+
 	return err;
 }
 

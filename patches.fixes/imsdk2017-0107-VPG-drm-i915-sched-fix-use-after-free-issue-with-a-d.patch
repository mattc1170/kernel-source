From 884d7273c5d8112f1fd29b05c39f9d01b990be0d Mon Sep 17 00:00:00 2001
From: Zhipeng Gong <zhipeng.gong@intel.com>
Date: Fri, 1 Apr 2016 05:26:57 +0800
Subject: [PATCH 107/143] [VPG]: drm/i915/sched: fix use-after-free issue with a dangling pointer.

When the queue is still full it can go back around the loop and look for a new request.
At the point of acquiring the spinlock, it could get stalled by other scheduler
processing on a different thread during which the queue becomes drained.
The for loop will fail to find a request but not update the value of req.
Thus the code will try to ref/wait/unref the old request a second time.
Except of course, it has already been freed by this point and is a dangling pointer.
Hence Bad Things happens.
---
 drivers/gpu/drm/i915/i915_scheduler.c |    3 ++-
 1 files changed, 2 insertions(+), 1 deletions(-)

diff --git a/drivers/gpu/drm/i915/i915_scheduler.c b/drivers/gpu/drm/i915/i915_scheduler.c
index 3c32a22..e67d76b 100644
--- a/drivers/gpu/drm/i915/i915_scheduler.c
+++ b/drivers/gpu/drm/i915/i915_scheduler.c
@@ -1293,7 +1293,7 @@ bool i915_scheduler_file_queue_wait(struct drm_file *file)
 	struct drm_i915_file_private *file_priv = file->driver_priv;
 	struct drm_i915_private *dev_priv  = file_priv->dev_priv;
 	struct i915_scheduler *scheduler = dev_priv->scheduler;
-	struct drm_i915_gem_request *req = NULL;
+	struct drm_i915_gem_request *req;
 	struct i915_scheduler_queue_entry *node;
 	unsigned reset_counter;
 	int i, ret;
@@ -1315,6 +1315,7 @@ bool i915_scheduler_file_queue_wait(struct drm_file *file)
 		 * still be correct and that case is not rare enough to add
 		 * jiffy based inter-ring checks.
 		 */
+		req = NULL;
 		for_each_ring(ring, dev_priv, i) {
 			for_each_scheduler_node(node, ring->id) {
 				if (I915_SQS_IS_COMPLETE(node))
-- 
1.7.1


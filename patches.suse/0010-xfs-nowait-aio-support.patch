From d62d7e422a5bb1f4dd99795b4b3889f3588fe69c Mon Sep 17 00:00:00 2001
From: Goldwyn Rodrigues <rgoldwyn@suse.com>
Date: Mon, 7 Aug 2017 14:54:48 -0500
Subject: [PATCH 10/10] xfs: nowait aio support
Git-commit: 29a5d29ec181ebdc98a26cedbd76ce9870248892
References: FATE#321994
Patch-mainline: 4.13-rc1


Since the kernel is missing fs/iomap support, the changes
were made completely in in xfs_file.c

If IOCB_NOWAIT is set, bail if the i_rwsem is not lockable
immediately.

Signed-off-by: Goldwyn Rodrigues <rgoldwyn@suse.com>
---
 fs/xfs/xfs_file.c | 54 +++++++++++++++++++++++++++++++++++++++++++++++-------
 1 file changed, 47 insertions(+), 7 deletions(-)

diff --git a/fs/xfs/xfs_file.c b/fs/xfs/xfs_file.c
index 4c790e751a46..14cc3e62669e 100644
--- a/fs/xfs/xfs_file.c
+++ b/fs/xfs/xfs_file.c
@@ -53,6 +53,19 @@ static struct vm_operations_struct xfs_dmapi_file_vm_ops;
  * Locking primitives for read and write IO paths to ensure we consistently use
  * and order the inode->i_mutex, ip->i_lock and ip->i_iolock.
  */
+static inline int
+xfs_rw_ilock_trylock(
+	struct xfs_inode	*ip,
+	int			type)
+{
+	if (type & XFS_IOLOCK_EXCL) {
+		if (!mutex_trylock(&VFS_I(ip)->i_mutex))
+			return -EAGAIN;
+	}
+	xfs_ilock(ip, type);
+	return 0;
+}
+
 static inline void
 xfs_rw_ilock(
 	struct xfs_inode	*ip,
@@ -678,6 +691,12 @@ restart:
 		bool	zero = false;
 
 		spin_unlock(&ip->i_flags_lock);
+
+		/* This will lead to a file allocation, bail if nowait */
+		if ((iocb->ki_flags & IOCB_NOWAIT) &&
+				(iocb->ki_flags &  IOCB_DIRECT))
+			return -EAGAIN;
+
 		if (!drained_dio) {
 			if (*iolock == XFS_IOLOCK_SHARED) {
 				xfs_rw_iunlock(ip, *iolock);
@@ -790,7 +809,11 @@ xfs_file_dio_aio_write(
 		iolock = XFS_IOLOCK_SHARED;
 	}
 
-	xfs_rw_ilock(ip, iolock);
+	if (xfs_rw_ilock_trylock(ip, iolock) < 0) {
+		if (iocb->ki_flags & IOCB_NOWAIT)
+			return -EAGAIN;
+		xfs_rw_ilock(ip, iolock);
+	}
 
 	ret = xfs_file_aio_write_checks(iocb, from, &iolock, eventsent);
 	if (ret)
@@ -799,9 +822,17 @@ xfs_file_dio_aio_write(
 	end = iocb->ki_pos + count - 1;
 
 	if (mapping->nrpages) {
-		ret = filemap_write_and_wait_range(mapping, iocb->ki_pos, end);
-		if (ret)
-			goto out;
+		if (iocb->ki_flags & IOCB_NOWAIT) {
+			if (filemap_range_has_page(mapping, iocb->ki_pos, end)) {
+				ret = -EAGAIN;
+				goto out;
+			}
+		} else {
+			ret = filemap_write_and_wait_range(mapping,
+					iocb->ki_pos, end);
+			if (ret)
+				goto out;
+		}
 
 		/*
 		 * Invalidate whole pages. This can return an error if we fail
@@ -819,9 +850,17 @@ xfs_file_dio_aio_write(
 	 * otherwise demote the lock if we had to take the exclusive lock
 	 * for other reasons in xfs_file_aio_write_checks.
 	 */
-	if (unaligned_io)
-		inode_dio_wait(inode);
-	else if (iolock == XFS_IOLOCK_EXCL) {
+	if (unaligned_io) {
+		/* If we are going to wait for other DIO to finish, bail */
+		if (iocb->ki_flags & IOCB_NOWAIT) {
+			if (atomic_read(&inode->i_dio_count)) {
+				ret = -EAGAIN;
+				goto out;
+			}
+		} else {
+			inode_dio_wait(inode);
+		}
+	} else if (iolock == XFS_IOLOCK_EXCL) {
 		xfs_rw_ilock_demote(ip, XFS_IOLOCK_EXCL);
 		iolock = XFS_IOLOCK_SHARED;
 	}
@@ -1104,6 +1143,7 @@ xfs_file_open(
 		return -EFBIG;
 	if (XFS_FORCED_SHUTDOWN(XFS_M(inode->i_sb)))
 		return -EIO;
+	file->f_mode |= FMODE_AIO_NOWAIT;
 	return 0;
 }
 
-- 
2.13.1


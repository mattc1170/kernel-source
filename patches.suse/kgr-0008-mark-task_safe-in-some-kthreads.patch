From: Jiri Slaby <jslaby@suse.cz>
Date: Wed, 29 Jan 2014 18:22:39 +0100
Subject: kgr: mark task_safe in some kthreads
Patch-mainline: not yet, kgraft
References: fate#313296 bnc#889207 bnc#891710 bnc#899908 bnc#905087 bnc#906140 bnc#962336

Before we enable a kthread support in kGraft, we must make sure all
kthreads mark themselves as kGraft-safe at some point explicitly.

We do this by injecting klp_kgraft_mark_task_safe to the freezer test.
There, we assume that kthreads are in some predefined state and can
expect something bad to happen. Hence we switch the kGraft worlds
there from the old one to the new one. The optimal solution would be
to convert most of kthreads (that need not be kthreads actually) to
workqeues as suggested by Tejun. This is an upcoming work that will
appear next.  But until we get there, we use freezer for kGraft that
way as is presented here.

Note that there are also some kthreads that do not utilize freezer, so
we use klp_kgraft_mark_task_safe in them explicitly. This happens at
locations that appear to be safe for the kthreads to switch the
worlds.

The end result after we migrate kthreads (that need not be kthreads)
to workqueues is: have only kthreads that contain
klp_kgraft_mark_task_safe explicitly (or using some helper) and
nothing else.

jk: issue klp_kgraft_mark_task_safe() for !CONFIG_FREEZER
jk: call klp_kgraft_mark_task_safe only for kthreads in fix try_to_freeze
js: one line, one command
js: usb-storage, mark kthread safe
mb: add kgraft annotations to kthreads' wait_event_freezable() API calls
mb: add kgraft annotation to hwrng kthread

Signed-off-by: Jiri Kosina <jkosina@suse.cz>
Signed-off-by: Miroslav Benes <mbenes@suse.cz>
Signed-off-by: Jiri Slaby <jslaby@suse.cz>
Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org> [devtmpfs]
Acked-by: Paul E. McKenney <paulmck@linux.vnet.ibm.com> [rcu]
Cc: Steven Rostedt <rostedt@goodmis.org>
Cc: Frederic Weisbecker <fweisbec@gmail.com>
Cc: Ingo Molnar <mingo@redhat.com>
Cc: "Theodore Ts'o" <tytso@mit.edu>
Cc: Dipankar Sarma <dipankar@in.ibm.com>
Cc: Tejun Heo <tj@kernel.org>
---
 arch/arm/common/bL_switcher.c                          |    4 +--
 arch/arm/mach-rpc/ecard.c                              |    4 ++-
 arch/powerpc/kernel/eeh_event.c                        |    2 +
 arch/powerpc/platforms/44x/warp.c                      |    1 
 arch/powerpc/platforms/83xx/mcu_mpc8349emitx.c         |    1 
 arch/powerpc/platforms/83xx/suspend.c                  |    4 ++-
 arch/powerpc/platforms/cell/spufs/sched.c              |    1 
 arch/powerpc/platforms/ps3/device-init.c               |    5 ++-
 arch/powerpc/platforms/pseries/cmm.c                   |    1 
 arch/s390/mm/cmm.c                                     |    5 ++-
 arch/sparc/kernel/ds.c                                 |    1 
 arch/x86/kernel/apm_32.c                               |    1 
 arch/x86/mm/pageattr-test.c                            |    1 
 drivers/acpi/acpi_pad.c                                |    2 +
 drivers/android/binder.c                               |    8 ++++--
 drivers/base/devtmpfs.c                                |    1 
 drivers/block/aoe/aoecmd.c                             |    1 
 drivers/block/cciss.c                                  |    2 +
 drivers/block/mtip32xx/mtip32xx.c                      |    6 +++-
 drivers/block/nbd.c                                    |    5 ++-
 drivers/bluetooth/btmrvl_main.c                        |    1 
 drivers/char/apm-emulation.c                           |   11 +++++---
 drivers/char/hw_random/core.c                          |    2 +
 drivers/char/ipmi/ipmi_si_intf.c                       |    2 +
 drivers/char/ipmi/ipmi_ssif.c                          |    2 +
 drivers/char/random.c                                  |    5 ++-
 drivers/char/virtio_console.c                          |   10 ++++---
 drivers/crypto/ccp/ccp-dev.c                           |    1 
 drivers/crypto/mv_cesa.c                               |    2 +
 drivers/crypto/mxs-dcp.c                               |    4 +++
 drivers/crypto/sahara.c                                |    1 
 drivers/dma/dmatest.c                                  |    6 +++-
 drivers/gpu/drm/amd/scheduler/gpu_scheduler.c          |    5 ++-
 drivers/hv/hv_balloon.c                                |    2 +
 drivers/hwmon/adt7470.c                                |    2 +
 drivers/infiniband/core/fmr_pool.c                     |    2 +
 drivers/infiniband/hw/nes/nes_mgt.c                    |    6 +++-
 drivers/isdn/mISDN/l1oip_core.c                        |    1 
 drivers/isdn/mISDN/stack.c                             |    6 +++-
 drivers/macintosh/mediabay.c                           |    2 +
 drivers/macintosh/therm_windtunnel.c                   |    2 +
 drivers/md/dm-crypt.c                                  |    1 
 drivers/md/md.c                                        |    4 +--
 drivers/media/dvb-core/dvb_ca_en50221.c                |    1 
 drivers/media/pci/ttpci/av7110.c                       |    2 +
 drivers/media/radio/radio-miropcm20.c                  |    2 +
 drivers/media/rc/lirc_dev.c                            |    3 ++
 drivers/media/rc/rc-ir-raw.c                           |    1 
 drivers/media/usb/gspca/m5602/m5602_s5k83a.c           |    2 +
 drivers/media/usb/pvrusb2/pvrusb2-context.c            |    5 ++-
 drivers/media/usb/pvrusb2/pvrusb2-dvb.c                |    5 ++-
 drivers/memstick/host/r592.c                           |    2 +
 drivers/memstick/host/rtsx_usb_ms.c                    |    2 +
 drivers/mfd/ucb1x00-ts.c                               |    2 +
 drivers/misc/genwqe/card_base.c                        |    2 +
 drivers/misc/genwqe/card_ddcb.c                        |    1 
 drivers/misc/kgdbts.c                                  |    5 +++
 drivers/misc/mic/cosm/cosm_scif_server.c               |    1 
 drivers/misc/mic/cosm_client/cosm_scif_client.c        |    2 +
 drivers/misc/sgi-xp/xpc_main.c                         |   10 ++++---
 drivers/mmc/card/queue.c                               |    1 
 drivers/mmc/core/sdio_irq.c                            |    1 
 drivers/net/ethernet/qualcomm/qca_spi.c                |    1 
 drivers/net/irda/stir4200.c                            |    2 -
 drivers/net/wimax/i2400m/usb-rx.c                      |    6 ++--
 drivers/net/wimax/i2400m/usb-tx.c                      |    6 ++--
 drivers/net/wireless/brcm80211/brcmfmac/sdio.c         |    1 
 drivers/net/wireless/libertas/main.c                   |    1 
 drivers/net/wireless/rsi/rsi_91x_main.c                |    1 
 drivers/net/wireless/rsi/rsi_91x_usb_ops.c             |    1 
 drivers/net/xen-netback/netback.c                      |    8 ++++--
 drivers/parisc/power.c                                 |    1 
 drivers/pci/hotplug/cpci_hotplug_core.c                |    2 +
 drivers/pci/hotplug/cpqphp_ctrl.c                      |    1 
 drivers/pci/hotplug/ibmphp_hpc.c                       |    1 
 drivers/platform/x86/intel_ips.c                       |    3 ++
 drivers/s390/cio/crw.c                                 |    5 ++-
 drivers/s390/scsi/zfcp_erp.c                           |    5 ++-
 drivers/sbus/char/bbc_envctrl.c                        |    1 
 drivers/sbus/char/envctrl.c                            |    1 
 drivers/scsi/aacraid/commsup.c                         |    2 +
 drivers/scsi/bnx2fc/bnx2fc_fcoe.c                      |    1 
 drivers/scsi/bnx2i/bnx2i_hwi.c                         |    2 +
 drivers/scsi/ibmvscsi/ibmvfc.c                         |    5 ++-
 drivers/scsi/ibmvscsi/ibmvscsi.c                       |    5 ++-
 drivers/scsi/lpfc/lpfc_hbadisc.c                       |    5 ++-
 drivers/scsi/mvumi.c                                   |    1 
 drivers/scsi/qla2xxx/qla_os.c                          |    1 
 drivers/scsi/scsi_error.c                              |    2 +
 drivers/staging/gdm72xx/gdm_usb.c                      |    5 ++-
 drivers/staging/lustre/lnet/klnds/o2iblnd/o2iblnd_cb.c |    3 ++
 drivers/staging/lustre/lnet/klnds/socklnd/socklnd_cb.c |    7 +++--
 drivers/staging/lustre/lnet/lnet/acceptor.c            |    1 
 drivers/staging/lustre/lnet/lnet/router.c              |    1 
 drivers/staging/lustre/lnet/selftest/timer.c           |    1 
 drivers/staging/lustre/lustre/ldlm/ldlm_lockd.c        |    5 ++-
 drivers/staging/lustre/lustre/ldlm/ldlm_pool.c         |    5 ++-
 drivers/staging/lustre/lustre/libcfs/tracefile.c       |    1 
 drivers/staging/lustre/lustre/libcfs/workitem.c        |    5 ++-
 drivers/staging/lustre/lustre/llite/llite_close.c      |    5 ++-
 drivers/staging/lustre/lustre/llite/lloop.c            |    3 +-
 drivers/staging/lustre/lustre/llite/statahead.c        |   10 ++++---
 drivers/staging/lustre/lustre/mgc/mgc_request.c        |    7 +++--
 drivers/staging/lustre/lustre/obdclass/genops.c        |    4 +--
 drivers/staging/lustre/lustre/ptlrpc/import.c          |    5 ++-
 drivers/staging/lustre/lustre/ptlrpc/pinger.c          |    5 ++-
 drivers/staging/lustre/lustre/ptlrpc/ptlrpcd.c         |    5 ++-
 drivers/staging/lustre/lustre/ptlrpc/sec_gc.c          |    5 ++-
 drivers/staging/lustre/lustre/ptlrpc/service.c         |    8 +++---
 drivers/staging/media/lirc/lirc_zilog.c                |    2 +
 drivers/staging/most/aim-sound/sound.c                 |    5 ++-
 drivers/staging/most/hdm-dim2/dim2_hdm.c               |    5 ++-
 drivers/staging/most/mostcore/core.c                   |    5 ++-
 drivers/staging/rtl8188eu/core/rtw_cmd.c               |    1 
 drivers/staging/rtl8712/rtl8712_cmd.c                  |    1 
 drivers/staging/rts5208/rtsx.c                         |    2 +
 drivers/staging/speakup/thread.c                       |    1 
 drivers/staging/unisys/visorhba/visorhba_main.c        |    5 ++-
 drivers/staging/wilc1000/host_interface.c              |    2 +
 drivers/staging/wilc1000/linux_wlan.c                  |    1 
 drivers/target/iscsi/iscsi_target.c                    |    7 +++--
 drivers/target/iscsi/iscsi_target_login.c              |    1 
 drivers/tty/bfin_jtag_comm.c                           |    3 ++
 drivers/tty/hvc/hvcs.c                                 |    1 
 drivers/tty/metag_da.c                                 |    5 ++-
 drivers/tty/mips_ejtag_fdc.c                           |   10 ++++---
 drivers/usb/early/ehci-dbgp.c                          |    1 
 drivers/usb/host/max3421-hcd.c                         |    2 +
 drivers/usb/storage/usb.c                              |   11 +++++++-
 drivers/usb/usbip/stub_rx.c                            |    1 
 drivers/usb/usbip/stub_tx.c                            |    5 ++-
 drivers/usb/usbip/usbip_event.c                        |    5 ++-
 drivers/usb/usbip/vhci_rx.c                            |    1 
 drivers/usb/usbip/vhci_tx.c                            |    5 ++-
 drivers/uwb/uwbd.c                                     |    5 ++-
 drivers/vhost/vhost.c                                  |    1 
 drivers/virtio/virtio_balloon.c                        |    2 +
 drivers/xen/xenbus/xenbus_xs.c                         |    5 ++-
 fs/btrfs/inode-map.c                                   |    1 
 fs/cifs/connect.c                                      |    1 
 fs/cifs/transport.c                                    |    5 ++-
 fs/dlm/lockspace.c                                     |    1 
 fs/dlm/recoverd.c                                      |    1 
 fs/ecryptfs/kthread.c                                  |    5 ++-
 fs/ext4/mmp.c                                          |    1 
 fs/f2fs/segment.c                                      |    5 ++-
 fs/jbd2/journal.c                                      |    2 +
 fs/jffs2/background.c                                  |    1 
 fs/jfs/jfs_logmgr.c                                    |    1 
 fs/jfs/jfs_txnmgr.c                                    |    2 +
 fs/nilfs2/segment.c                                    |    1 
 fs/ocfs2/cluster/heartbeat.c                           |    1 
 fs/ocfs2/dlm/dlmrecovery.c                             |   10 ++++---
 fs/ocfs2/dlm/dlmthread.c                               |    5 ++-
 fs/ocfs2/dlmglue.c                                     |    5 ++-
 fs/ocfs2/journal.c                                     |    5 ++-
 fs/xfs/xfs_trans_ail.c                                 |    2 +
 include/linux/freezer.h                                |   11 +++++++-
 kernel/audit_tree.c                                    |    2 +
 kernel/hung_task.c                                     |    5 +++
 kernel/irq/manage.c                                    |    1 
 kernel/kthread.c                                       |    3 ++
 kernel/locking/locktorture.c                           |    3 ++
 kernel/power/swap.c                                    |   15 ++++++-----
 kernel/rcu/rcutorture.c                                |   22 +++++++++++++----
 kernel/rcu/tree.c                                      |    6 +++-
 kernel/rcu/tree_plugin.h                               |   18 ++++++++++---
 kernel/rcu/update.c                                    |    5 ++-
 kernel/smpboot.c                                       |    2 +
 kernel/torture.c                                       |    4 +++
 kernel/trace/ring_buffer.c                             |    2 +
 kernel/trace/ring_buffer_benchmark.c                   |    2 +
 kernel/trace/trace_benchmark.c                         |    1 
 kernel/trace/trace_events.c                            |    1 
 kernel/trace/trace_selftest.c                          |    1 
 kernel/workqueue.c                                     |    3 ++
 mm/huge_memory.c                                       |   10 +++++--
 mm/kmemleak.c                                          |    2 +
 mm/ksm.c                                               |    5 ++-
 net/bluetooth/bnep/core.c                              |    1 
 net/bluetooth/cmtp/core.c                              |    1 
 net/bluetooth/hidp/core.c                              |    1 
 net/bluetooth/rfcomm/core.c                            |    2 +
 net/netfilter/ipvs/ip_vs_sync.c                        |   11 +++++---
 samples/trace_events/trace-events-sample.c             |    1 
 sound/pci/emu10k1/emu10k1_main.c                       |    1 
 186 files changed, 478 insertions(+), 168 deletions(-)

--- a/arch/arm/common/bL_switcher.c
+++ b/arch/arm/common/bL_switcher.c
@@ -283,9 +283,9 @@ static int bL_switcher_thread(void *arg)
 	do {
 		if (signal_pending(current))
 			flush_signals(current);
-		wait_event_interruptible(t->wq,
+		wait_event_interruptible(t->wq, ({ klp_kgraft_mark_task_safe(current);
 				t->wanted_cluster != -1 ||
-				kthread_should_stop());
+				kthread_should_stop(); }));
 
 		spin_lock(&t->lock);
 		cluster = t->wanted_cluster;
--- a/arch/arm/mach-rpc/ecard.c
+++ b/arch/arm/mach-rpc/ecard.c
@@ -274,7 +274,9 @@ ecard_task(void * unused)
 	while (1) {
 		struct ecard_request *req;
 
-		wait_event_interruptible(ecard_wait, ecard_req != NULL);
+		wait_event_interruptible(ecard_wait, ({
+					klp_kgraft_mark_task_safe(current);
+					ecard_req != NULL; }));
 
 		req = xchg(&ecard_req, NULL);
 		if (req != NULL) {
--- a/arch/powerpc/kernel/eeh_event.c
+++ b/arch/powerpc/kernel/eeh_event.c
@@ -55,6 +55,8 @@ static int eeh_event_handler(void * dumm
 	struct eeh_pe *pe;
 
 	while (!kthread_should_stop()) {
+		klp_kgraft_mark_task_safe(current);
+
 		if (down_interruptible(&eeh_eventlist_sem))
 			break;
 
--- a/arch/powerpc/platforms/44x/warp.c
+++ b/arch/powerpc/platforms/44x/warp.c
@@ -268,6 +268,7 @@ static int pika_dtm_thread(void __iomem
 
 		set_current_state(TASK_INTERRUPTIBLE);
 		schedule_timeout(HZ);
+		klp_kgraft_mark_task_safe(current);
 	}
 
 	return 0;
--- a/arch/powerpc/platforms/83xx/mcu_mpc8349emitx.c
+++ b/arch/powerpc/platforms/83xx/mcu_mpc8349emitx.c
@@ -66,6 +66,7 @@ static int shutdown_thread_fn(void *data
 
 		set_current_state(TASK_INTERRUPTIBLE);
 		schedule_timeout(HZ);
+		klp_kgraft_mark_task_safe(current);
 	}
 
 	return 0;
--- a/arch/powerpc/platforms/83xx/suspend.c
+++ b/arch/powerpc/platforms/83xx/suspend.c
@@ -265,7 +265,9 @@ static int mpc83xx_suspend_begin(suspend
 static int agent_thread_fn(void *data)
 {
 	while (1) {
-		wait_event_interruptible(agent_wq, pci_pm_state >= 2);
+		wait_event_interruptible(agent_wq, ({
+				klp_kgraft_mark_task_safe(current);
+				pci_pm_state >= 2; }));
 		try_to_freeze();
 
 		if (signal_pending(current) || pci_pm_state < 2)
--- a/arch/powerpc/platforms/cell/spufs/sched.c
+++ b/arch/powerpc/platforms/cell/spufs/sched.c
@@ -1011,6 +1011,7 @@ static int spusched_thread(void *unused)
 	while (!kthread_should_stop()) {
 		set_current_state(TASK_INTERRUPTIBLE);
 		schedule();
+		klp_kgraft_mark_task_safe(current);
 		for (node = 0; node < MAX_NUMNODES; node++) {
 			struct mutex *mtx = &cbe_spu_info[node].list_mutex;
 
--- a/arch/powerpc/platforms/ps3/device-init.c
+++ b/arch/powerpc/platforms/ps3/device-init.c
@@ -752,8 +752,9 @@ static int ps3_notification_read_write(s
 	}
 	pr_debug("%s:%u: notification %s issued\n", __func__, __LINE__, op);
 
-	res = wait_event_interruptible(dev->done.wait,
-				       dev->done.done || kthread_should_stop());
+	res = wait_event_interruptible(dev->done.wait, ({
+				klp_kgraft_mark_task_safe(current);
+				dev->done.done || kthread_should_stop(); }));
 	if (kthread_should_stop())
 		res = -EINTR;
 	if (res) {
--- a/arch/powerpc/platforms/pseries/cmm.c
+++ b/arch/powerpc/platforms/pseries/cmm.c
@@ -308,6 +308,7 @@ static int cmm_thread(void *dummy)
 
 	while (1) {
 		timeleft = msleep_interruptible(delay * 1000);
+		klp_kgraft_mark_task_safe(current);
 
 		if (kthread_should_stop() || timeleft)
 			break;
--- a/arch/s390/mm/cmm.c
+++ b/arch/s390/mm/cmm.c
@@ -148,10 +148,11 @@ static int cmm_thread(void *dummy)
 	int rc;
 
 	while (1) {
-		rc = wait_event_interruptible(cmm_thread_wait,
+		rc = wait_event_interruptible(cmm_thread_wait, ({
+			klp_kgraft_mark_task_safe(current);
 			(!cmm_suspended && (cmm_pages != cmm_pages_target ||
 			 cmm_timed_pages != cmm_timed_pages_target)) ||
-			 kthread_should_stop());
+			 kthread_should_stop(); }));
 		if (kthread_should_stop() || rc == -ERESTARTSYS) {
 			cmm_pages_target = cmm_pages;
 			cmm_timed_pages_target = cmm_timed_pages;
--- a/arch/sparc/kernel/ds.c
+++ b/arch/sparc/kernel/ds.c
@@ -1032,6 +1032,7 @@ static int ds_thread(void *__unused)
 		if (list_empty(&ds_work_list))
 			schedule();
 		finish_wait(&ds_wait, &wait);
+		klp_kgraft_mark_task_safe(current);
 
 		if (kthread_should_stop())
 			break;
--- a/arch/x86/kernel/apm_32.c
+++ b/arch/x86/kernel/apm_32.c
@@ -1438,6 +1438,7 @@ static void apm_mainloop(void)
 	set_current_state(TASK_INTERRUPTIBLE);
 	for (;;) {
 		schedule_timeout(APM_CHECK_TIMEOUT);
+		klp_kgraft_mark_task_safe(current);
 		if (kthread_should_stop())
 			break;
 		/*
--- a/arch/x86/mm/pageattr-test.c
+++ b/arch/x86/mm/pageattr-test.c
@@ -237,6 +237,7 @@ static int do_pageattr_test(void *__unus
 {
 	while (!kthread_should_stop()) {
 		schedule_timeout_interruptible(HZ*30);
+		klp_kgraft_mark_task_safe(current);
 		if (pageattr_test() < 0)
 			break;
 		if (print)
--- a/drivers/acpi/acpi_pad.c
+++ b/drivers/acpi/acpi_pad.c
@@ -148,6 +148,8 @@ static int power_saving_thread(void *dat
 	while (!kthread_should_stop()) {
 		unsigned long expire_time;
 
+		klp_kgraft_mark_task_safe(current);
+
 		/* round robin to cpus */
 		expire_time = last_jiffies + round_robin_time * HZ;
 		if (time_before(expire_time, jiffies)) {
--- a/drivers/android/binder.c
+++ b/drivers/android/binder.c
@@ -2202,13 +2202,17 @@ retry:
 			if (!binder_has_proc_work(proc, thread))
 				ret = -EAGAIN;
 		} else
-			ret = wait_event_freezable_exclusive(proc->wait, binder_has_proc_work(proc, thread));
+			ret = wait_event_freezable_exclusive(proc->wait, ({
+					klp_kgraft_mark_task_safe(current);
+					binder_has_proc_work(proc, thread); }));
 	} else {
 		if (non_block) {
 			if (!binder_has_thread_work(thread))
 				ret = -EAGAIN;
 		} else
-			ret = wait_event_freezable(thread->wait, binder_has_thread_work(thread));
+			ret = wait_event_freezable(thread->wait, ({
+						   klp_kgraft_mark_task_safe(current);
+						   binder_has_thread_work(thread); }));
 	}
 
 	binder_lock(__func__);
--- a/drivers/base/devtmpfs.c
+++ b/drivers/base/devtmpfs.c
@@ -387,6 +387,7 @@ static int devtmpfsd(void *p)
 	sys_chroot(".");
 	complete(&setup_done);
 	while (1) {
+		klp_kgraft_mark_task_safe(current);
 		spin_lock(&req_lock);
 		while (requests) {
 			struct req *req = requests;
--- a/drivers/block/aoe/aoecmd.c
+++ b/drivers/block/aoe/aoecmd.c
@@ -1296,6 +1296,7 @@ kthread(void *vp)
 	set_user_nice(current, -10);
 	complete(&k->rendez);	/* tell spawner we're running */
 	do {
+		klp_kgraft_mark_task_safe(current);
 		spin_lock_irq(k->lock);
 		more = k->fn(k->id);
 		if (!more) {
--- a/drivers/block/cciss.c
+++ b/drivers/block/cciss.c
@@ -3748,6 +3748,8 @@ static int scan_thread(void *data)
 		if (kthread_should_stop())
 			break;
 
+		klp_kgraft_mark_task_safe(current);
+
 		while (1) {
 			mutex_lock(&scan_mutex);
 			if (list_empty(&scan_q)) {
--- a/drivers/block/mtip32xx/mtip32xx.c
+++ b/drivers/block/mtip32xx/mtip32xx.c
@@ -2964,8 +2964,10 @@ static int mtip_service_thread(void *dat
 		 * the condition is to check neither an internal command is
 		 * is in progress nor error handling is active
 		 */
-		wait_event_interruptible(port->svc_wait, (port->flags) &&
-			(port->flags & MTIP_PF_SVC_THD_WORK));
+		wait_event_interruptible(port->svc_wait, ({
+			klp_kgraft_mark_task_safe(current);
+			(port->flags) &&
+			(port->flags & MTIP_PF_SVC_THD_WORK); }));
 
 		if (kthread_should_stop() ||
 			test_bit(MTIP_PF_SVC_THD_STOP_BIT, &port->flags))
--- a/drivers/block/nbd.c
+++ b/drivers/block/nbd.c
@@ -553,9 +553,10 @@ static int nbd_thread_send(void *data)
 	set_user_nice(current, MIN_NICE);
 	while (!kthread_should_stop() || !list_empty(&nbd->waiting_queue)) {
 		/* wait for something to do */
-		wait_event_interruptible(nbd->waiting_wq,
+		wait_event_interruptible(nbd->waiting_wq, ({
+					 klp_kgraft_mark_task_safe(current);
 					 kthread_should_stop() ||
-					 !list_empty(&nbd->waiting_queue));
+					 !list_empty(&nbd->waiting_queue); }));
 
 		if (signal_pending(current)) {
 			int ret = kernel_dequeue_signal(NULL);
--- a/drivers/bluetooth/btmrvl_main.c
+++ b/drivers/bluetooth/btmrvl_main.c
@@ -598,6 +598,7 @@ static int btmrvl_service_main_thread(vo
 	init_waitqueue_entry(&wait, current);
 
 	for (;;) {
+		klp_kgraft_mark_task_safe(current);
 		add_wait_queue(&thread->wait_q, &wait);
 
 		set_current_state(TASK_INTERRUPTIBLE);
--- a/drivers/char/apm-emulation.c
+++ b/drivers/char/apm-emulation.c
@@ -300,8 +300,9 @@ apm_ioctl(struct file *filp, u_int cmd,
 			 * signal can cause busy looping.  We aren't doing
 			 * anything critical, chill a bit on each iteration.
 			 */
-			while (wait_event_freezable(apm_suspend_waitqueue,
-					as->suspend_state != SUSPEND_ACKED))
+			while (wait_event_freezable(apm_suspend_waitqueue, ({
+					klp_kgraft_mark_task_safe(current);
+					as->suspend_state != SUSPEND_ACKED; })))
 				msleep(10);
 			break;
 		case SUSPEND_ACKTO:
@@ -488,8 +489,10 @@ static int kapmd(void *arg)
 	do {
 		apm_event_t event;
 
-		wait_event_interruptible(kapmd_wait,
-				!queue_empty(&kapmd_queue) || kthread_should_stop());
+		wait_event_interruptible(kapmd_wait, ({
+				klp_kgraft_mark_task_safe(current);
+				!queue_empty(&kapmd_queue) ||
+				kthread_should_stop(); }));
 
 		if (kthread_should_stop())
 			break;
--- a/drivers/char/hw_random/core.c
+++ b/drivers/char/hw_random/core.c
@@ -409,6 +409,8 @@ static int hwrng_fillfn(void *unused)
 	while (!kthread_should_stop()) {
 		struct hwrng *rng;
 
+		klp_kgraft_mark_task_safe(current);
+
 		rng = get_current_rng();
 		if (IS_ERR(rng) || !rng)
 			break;
--- a/drivers/char/ipmi/ipmi_si_intf.c
+++ b/drivers/char/ipmi/ipmi_si_intf.c
@@ -1076,6 +1076,8 @@ static int ipmi_thread(void *data)
 	while (!kthread_should_stop()) {
 		int busy_wait;
 
+		klp_kgraft_mark_task_safe(current);
+
 		spin_lock_irqsave(&(smi_info->si_lock), flags);
 		smi_result = smi_event_handler(smi_info, 0);
 
--- a/drivers/char/ipmi/ipmi_ssif.c
+++ b/drivers/char/ipmi/ipmi_ssif.c
@@ -479,6 +479,8 @@ static int ipmi_ssif_thread(void *data)
 	while (!kthread_should_stop()) {
 		int result;
 
+		klp_kgraft_mark_task_safe(current); /* insufficient */
+
 		/* Wait for something to do */
 		result = wait_for_completion_interruptible(
 						&ssif_info->wake_thread);
--- a/drivers/char/random.c
+++ b/drivers/char/random.c
@@ -1860,9 +1860,10 @@ void add_hwgenerator_randomness(const ch
 		 * random_write_wakeup_thresh, or when the calling
 		 * thread is about to terminate.
 		 */
-		wait_event_interruptible(random_write_wait,
+		wait_event_interruptible(random_write_wait, ({
+					 klp_kgraft_mark_task_safe(current);
 					 kthread_should_stop() ||
-			ENTROPY_BITS(&input_pool) <= random_write_wakeup_bits);
+			ENTROPY_BITS(&input_pool) <= random_write_wakeup_bits; }));
 	}
 	mix_pool_bytes(poolp, buffer, count);
 	credit_entropy_bits(poolp, entropy);
--- a/drivers/char/virtio_console.c
+++ b/drivers/char/virtio_console.c
@@ -768,8 +768,9 @@ static ssize_t port_fops_read(struct fil
 		if (filp->f_flags & O_NONBLOCK)
 			return -EAGAIN;
 
-		ret = wait_event_freezable(port->waitqueue,
-					   !will_read_block(port));
+		ret = wait_event_freezable(port->waitqueue, ({
+					   klp_kgraft_mark_task_safe(current);
+					   !will_read_block(port); }));
 		if (ret < 0)
 			return ret;
 	}
@@ -800,8 +801,9 @@ static int wait_port_writable(struct por
 		if (nonblock)
 			return -EAGAIN;
 
-		ret = wait_event_freezable(port->waitqueue,
-					   !will_write_block(port));
+		ret = wait_event_freezable(port->waitqueue, ({
+					   klp_kgraft_mark_task_safe(current);
+					   !will_write_block(port); }));
 		if (ret < 0)
 			return ret;
 	}
--- a/drivers/crypto/ccp/ccp-dev.c
+++ b/drivers/crypto/ccp/ccp-dev.c
@@ -234,6 +234,7 @@ static int ccp_cmd_queue_thread(void *da
 	while (!kthread_should_stop()) {
 		schedule();
 
+		klp_kgraft_mark_task_safe(current);
 		set_current_state(TASK_INTERRUPTIBLE);
 
 		cmd = ccp_dequeue_cmd(cmd_q);
--- a/drivers/crypto/mv_cesa.c
+++ b/drivers/crypto/mv_cesa.c
@@ -639,6 +639,8 @@ static int queue_manag(void *data)
 
 		schedule();
 
+		klp_kgraft_mark_task_safe(current);
+
 	} while (!kthread_should_stop());
 	return 0;
 }
--- a/drivers/crypto/mxs-dcp.c
+++ b/drivers/crypto/mxs-dcp.c
@@ -367,6 +367,8 @@ static int dcp_chan_thread_aes(void *dat
 		}
 
 		schedule();
+
+		klp_kgraft_mark_task_safe(current);
 	} while (!kthread_should_stop());
 
 	return 0;
@@ -668,6 +670,8 @@ static int dcp_chan_thread_sha(void *dat
 		}
 
 		schedule();
+
+		klp_kgraft_mark_task_safe(current);
 	} while (!kthread_should_stop());
 
 	return 0;
--- a/drivers/crypto/sahara.c
+++ b/drivers/crypto/sahara.c
@@ -1040,6 +1040,7 @@ static int sahara_queue_manage(void *dat
 	int ret = 0;
 
 	do {
+		klp_kgraft_mark_task_safe(current);
 		__set_current_state(TASK_INTERRUPTIBLE);
 
 		mutex_lock(&dev->queue_mutex);
--- a/drivers/dma/dmatest.c
+++ b/drivers/dma/dmatest.c
@@ -488,6 +488,8 @@ static int dmatest_func(void *data)
 
 		total_tests++;
 
+		klp_kgraft_mark_task_safe(current);
+
 		/* honor alignment restrictions */
 		if (thread->type == DMA_MEMCPY)
 			align = dev->copy_align;
@@ -620,7 +622,9 @@ static int dmatest_func(void *data)
 		}
 		dma_async_issue_pending(chan);
 
-		wait_event_freezable_timeout(done_wait, done.done,
+		wait_event_freezable_timeout(done_wait, ({
+					     klp_kgraft_mark_task_safe(current);
+					     done.done; }),
 					     msecs_to_jiffies(params->timeout));
 
 		status = dma_async_is_tx_complete(chan, cookie, NULL, NULL);
--- a/drivers/gpu/drm/amd/scheduler/gpu_scheduler.c
+++ b/drivers/gpu/drm/amd/scheduler/gpu_scheduler.c
@@ -419,9 +419,10 @@ static int amd_sched_main(void *param)
 		struct fence *fence;
 		unsigned long flags;
 
-		wait_event_interruptible(sched->wake_up_worker,
+		wait_event_interruptible(sched->wake_up_worker, ({
+			klp_kgraft_mark_task_safe(current);
 			(entity = amd_sched_select_entity(sched)) ||
-			kthread_should_stop());
+			kthread_should_stop(); }));
 
 		if (!entity)
 			continue;
--- a/drivers/hv/hv_balloon.c
+++ b/drivers/hv/hv_balloon.c
@@ -1259,6 +1259,8 @@ static int dm_thread_func(void *dm_dev)
 	struct hv_dynmem_device *dm = dm_dev;
 
 	while (!kthread_should_stop()) {
+		klp_kgraft_mark_task_safe(current);
+
 		wait_for_completion_interruptible_timeout(
 						&dm_device.config_event, 1*HZ);
 		/*
--- a/drivers/hwmon/adt7470.c
+++ b/drivers/hwmon/adt7470.c
@@ -263,6 +263,8 @@ static int adt7470_update_thread(void *p
 	struct adt7470_data *data = i2c_get_clientdata(client);
 
 	while (!kthread_should_stop()) {
+		klp_kgraft_mark_task_safe(current);
+
 		mutex_lock(&data->lock);
 		adt7470_read_temperatures(client, data);
 		mutex_unlock(&data->lock);
--- a/drivers/infiniband/core/fmr_pool.c
+++ b/drivers/infiniband/core/fmr_pool.c
@@ -179,6 +179,8 @@ static int ib_fmr_cleanup_thread(void *p
 	struct ib_fmr_pool *pool = pool_ptr;
 
 	do {
+		klp_kgraft_mark_task_safe(current);
+
 		if (atomic_read(&pool->flush_ser) - atomic_read(&pool->req_ser) < 0) {
 			ib_fmr_batch_release(pool);
 
--- a/drivers/infiniband/hw/nes/nes_mgt.c
+++ b/drivers/infiniband/hw/nes/nes_mgt.c
@@ -582,8 +582,10 @@ static int mgt_thread(void *context)
 	struct nes_rskb_cb *cb;
 
 	while (!kthread_should_stop()) {
-		wait_event_interruptible(nesvnic->mgt_wait_queue,
-					 skb_queue_len(&nesvnic->mgt_skb_list) || kthread_should_stop());
+		wait_event_interruptible(nesvnic->mgt_wait_queue, ({
+					 klp_kgraft_mark_task_safe(current);
+					 skb_queue_len(&nesvnic->mgt_skb_list) ||
+					 kthread_should_stop(); }));
 		while ((skb_queue_len(&nesvnic->mgt_skb_list)) && !kthread_should_stop()) {
 			skb = skb_dequeue(&nesvnic->mgt_skb_list);
 			cb = (struct nes_rskb_cb *)&skb->cb[0];
--- a/drivers/isdn/mISDN/l1oip_core.c
+++ b/drivers/isdn/mISDN/l1oip_core.c
@@ -736,6 +736,7 @@ l1oip_socket_thread(void *data)
 				printk(KERN_WARNING
 				       "%s: broken pipe on socket\n", __func__);
 		}
+		klp_kgraft_mark_task_safe(current); /* insufficient */
 	}
 
 	/* get socket back, check first if in use, maybe by send function */
--- a/drivers/isdn/mISDN/stack.c
+++ b/drivers/isdn/mISDN/stack.c
@@ -285,8 +285,10 @@ mISDNStackd(void *data)
 		st->sleep_cnt++;
 #endif
 		test_and_clear_bit(mISDN_STACK_ACTIVE, &st->status);
-		wait_event_interruptible(st->workq, (st->status &
-						     mISDN_STACK_ACTION_MASK));
+		wait_event_interruptible(st->workq, ({
+					klp_kgraft_mark_task_safe(current);
+					(st->status &
+						     mISDN_STACK_ACTION_MASK); }));
 		if (*debug & DEBUG_MSG_THREAD)
 			printk(KERN_DEBUG "%s: %s wake status %08lx\n",
 			       __func__, dev_name(&st->dev->dev), st->status);
--- a/drivers/macintosh/mediabay.c
+++ b/drivers/macintosh/mediabay.c
@@ -544,6 +544,8 @@ static int media_bay_task(void *x)
 	int	i;
 
 	while (!kthread_should_stop()) {
+		klp_kgraft_mark_task_safe(current);
+
 		for (i = 0; i < media_bay_count; ++i) {
 			mutex_lock(&media_bays[i].lock);
 			if (!media_bays[i].sleeping)
--- a/drivers/macintosh/therm_windtunnel.c
+++ b/drivers/macintosh/therm_windtunnel.c
@@ -279,6 +279,8 @@ static int control_loop(void *dummy)
 	mutex_unlock(&x.lock);
 
 	for (;;) {
+		klp_kgraft_mark_task_safe(current);
+
 		msleep_interruptible(8000);
 		if (kthread_should_stop())
 			break;
--- a/drivers/md/dm-crypt.c
+++ b/drivers/md/dm-crypt.c
@@ -1202,6 +1202,7 @@ static int dmcrypt_write(void *data)
 
 		spin_lock_irq(&cc->write_thread_wait.lock);
 continue_locked:
+		klp_kgraft_mark_task_safe(current);
 
 		if (!RB_EMPTY_ROOT(&cc->write_tree))
 			goto pop_from_list;
--- a/drivers/md/md.c
+++ b/drivers/md/md.c
@@ -7227,9 +7227,9 @@ static int md_thread(void *arg)
 			flush_signals(current);
 
 		wait_event_interruptible_timeout
-			(thread->wqueue,
+			(thread->wqueue, ({ klp_kgraft_mark_task_safe(current);
 			 test_bit(THREAD_WAKEUP, &thread->flags)
-			 || kthread_should_stop(),
+			 || kthread_should_stop(); }),
 			 thread->timeout);
 
 		clear_bit(THREAD_WAKEUP, &thread->flags);
--- a/drivers/media/dvb-core/dvb_ca_en50221.c
+++ b/drivers/media/dvb-core/dvb_ca_en50221.c
@@ -996,6 +996,7 @@ static int dvb_ca_en50221_thread(void *d
 				return 0;
 		}
 		ca->wakeup = 0;
+		klp_kgraft_mark_task_safe(current);
 
 		/* go through all the slots processing them */
 		for (slot = 0; slot < ca->slot_count; slot++) {
--- a/drivers/media/pci/ttpci/av7110.c
+++ b/drivers/media/pci/ttpci/av7110.c
@@ -265,6 +265,8 @@ static int arm_thread(void *data)
 			break;
 		}
 
+		klp_kgraft_mark_task_safe(current);
+
 		if (!av7110->arm_ready)
 			continue;
 
--- a/drivers/media/radio/radio-miropcm20.c
+++ b/drivers/media/radio/radio-miropcm20.c
@@ -323,6 +323,8 @@ static int pcm20_thread(void *data)
 		if (kthread_should_stop())
 			break;
 
+		klp_kgraft_mark_task_safe(current);
+
 		res = rds_cmd(dev->aci, RDS_RXVALUE, &buf, 1);
 		if (res)
 			continue;
--- a/drivers/media/rc/lirc_dev.c
+++ b/drivers/media/rc/lirc_dev.c
@@ -131,6 +131,8 @@ static int lirc_thread(void *irctl)
 		ir->d.name, ir->d.minor);
 
 	do {
+		klp_kgraft_mark_task_safe(current);
+
 		if (ir->open) {
 			if (ir->jiffies_to_wait) {
 				set_current_state(TASK_INTERRUPTIBLE);
@@ -144,6 +146,7 @@ static int lirc_thread(void *irctl)
 			set_current_state(TASK_INTERRUPTIBLE);
 			schedule();
 		}
+
 	} while (!kthread_should_stop());
 
 	dev_dbg(ir->d.dev, LOGHEAD "poll thread ended\n",
--- a/drivers/media/rc/rc-ir-raw.c
+++ b/drivers/media/rc/rc-ir-raw.c
@@ -39,6 +39,7 @@ static int ir_raw_event_thread(void *dat
 	int retval;
 
 	while (!kthread_should_stop()) {
+		klp_kgraft_mark_task_safe(current);
 
 		spin_lock_irq(&raw->lock);
 		retval = kfifo_len(&raw->kfifo);
--- a/drivers/media/usb/gspca/m5602/m5602_s5k83a.c
+++ b/drivers/media/usb/gspca/m5602/m5602_s5k83a.c
@@ -178,6 +178,8 @@ static int rotation_thread_function(void
 
 	set_current_state(TASK_INTERRUPTIBLE);
 	while (!schedule_timeout(msecs_to_jiffies(100))) {
+		klp_kgraft_mark_task_safe(current);
+
 		if (mutex_lock_interruptible(&sd->gspca_dev.usb_lock))
 			break;
 
--- a/drivers/media/usb/pvrusb2/pvrusb2-context.c
+++ b/drivers/media/usb/pvrusb2/pvrusb2-context.c
@@ -171,9 +171,10 @@ static int pvr2_context_thread_func(void
 			pvr2_context_check(mp);
 		}
 		wait_event_interruptible(
-			pvr2_context_sync_data,
+			pvr2_context_sync_data, ({
+			klp_kgraft_mark_task_safe(current);
 			((pvr2_context_notify_first != NULL) ||
-			 pvr2_context_shutok()));
+			 pvr2_context_shutok()); }));
 	} while (!pvr2_context_shutok());
 
 	pvr2_context_cleaned_flag = !0;
--- a/drivers/media/usb/pvrusb2/pvrusb2-dvb.c
+++ b/drivers/media/usb/pvrusb2/pvrusb2-dvb.c
@@ -76,9 +76,10 @@ static int pvr2_dvb_feed_func(struct pvr
 		/* Wait until more buffers become available or we're
 		   told not to wait any longer. */
 		ret = wait_event_interruptible(
-		    adap->buffer_wait_data,
+		    adap->buffer_wait_data, ({
+		    klp_kgraft_mark_task_safe(current);
 		    (pvr2_stream_get_ready_count(stream) > 0) ||
-		    kthread_should_stop());
+		    kthread_should_stop(); }));
 		if (ret < 0) break;
 	}
 
--- a/drivers/memstick/host/r592.c
+++ b/drivers/memstick/host/r592.c
@@ -571,6 +571,8 @@ static int r592_process_thread(void *dat
 	unsigned long flags;
 
 	while (!kthread_should_stop()) {
+		klp_kgraft_mark_task_safe(current);
+
 		spin_lock_irqsave(&dev->io_thread_lock, flags);
 		set_current_state(TASK_INTERRUPTIBLE);
 		error = memstick_next_req(dev->host, &dev->req);
--- a/drivers/memstick/host/rtsx_usb_ms.c
+++ b/drivers/memstick/host/rtsx_usb_ms.c
@@ -685,6 +685,8 @@ static int rtsx_usb_detect_ms_card(void
 	int err;
 
 	for (;;) {
+		klp_kgraft_mark_task_safe(current);
+
 		pm_runtime_get_sync(ms_dev(host));
 		mutex_lock(&ucr->dev_mutex);
 
--- a/drivers/mfd/ucb1x00-ts.c
+++ b/drivers/mfd/ucb1x00-ts.c
@@ -220,6 +220,8 @@ static int ucb1x00_thread(void *_ts)
 		if (frozen)
 			ignore = true;
 
+		klp_kgraft_mark_task_safe(current);
+
 		ucb1x00_adc_enable(ts->ucb);
 
 		x = ucb1x00_ts_read_xpos(ts);
--- a/drivers/misc/genwqe/card_base.c
+++ b/drivers/misc/genwqe/card_base.c
@@ -916,6 +916,8 @@ static int genwqe_health_thread(void *da
 
  health_thread_begin:
 	while (!kthread_should_stop()) {
+		klp_kgraft_mark_task_safe(current);
+
 		rc = wait_event_interruptible_timeout(cd->health_waitq,
 			 (genwqe_health_check_cond(cd, &gfir) ||
 			  (should_stop = kthread_should_stop())),
--- a/drivers/misc/genwqe/card_ddcb.c
+++ b/drivers/misc/genwqe/card_ddcb.c
@@ -1193,6 +1193,7 @@ static int genwqe_card_thread(void *data
 	struct genwqe_dev *cd = (struct genwqe_dev *)data;
 
 	while (!kthread_should_stop()) {
+		klp_kgraft_mark_task_safe(current);
 
 		genwqe_check_ddcb_queue(cd, &cd->queue);
 
--- a/drivers/misc/kgdbts.c
+++ b/drivers/misc/kgdbts.c
@@ -191,8 +191,11 @@ static int kgdbts_unreg_thread(void *ptr
 	/* Wait until the tests are complete and then ungresiter the I/O
 	 * driver.
 	 */
-	while (!final_ack)
+	while (!final_ack) {
+		klp_kgraft_mark_task_safe(current);
+
 		msleep_interruptible(1500);
+	}
 	/* Pause for any other threads to exit after final ack. */
 	msleep_interruptible(1000);
 	if (configured)
--- a/drivers/misc/mic/cosm/cosm_scif_server.c
+++ b/drivers/misc/mic/cosm/cosm_scif_server.c
@@ -297,6 +297,7 @@ static int cosm_scif_server(void *unused
 	allow_signal(SIGKILL);
 
 	while (!kthread_should_stop()) {
+		klp_kgraft_mark_task_safe(current); /* insufficient */
 		rc = scif_accept(listen_epd, &port_id, &newepd,
 				 SCIF_ACCEPT_SYNC);
 		if (rc < 0) {
--- a/drivers/misc/mic/cosm_client/cosm_scif_client.c
+++ b/drivers/misc/mic/cosm_client/cosm_scif_client.c
@@ -157,6 +157,8 @@ static int cosm_scif_client(void *unused
 	allow_signal(SIGKILL);
 
 	while (!kthread_should_stop()) {
+		klp_kgraft_mark_task_safe(current);
+
 		pollepd.epd = client_epd;
 		pollepd.events = POLLIN;
 
--- a/drivers/misc/sgi-xp/xpc_main.c
+++ b/drivers/misc/sgi-xp/xpc_main.c
@@ -298,11 +298,12 @@ xpc_hb_checker(void *ignore)
 		}
 
 		/* wait for IRQ or timeout */
-		(void)wait_event_interruptible(xpc_activate_IRQ_wq,
+		(void)wait_event_interruptible(xpc_activate_IRQ_wq, ({
+					       klp_kgraft_mark_task_safe(current);
 					       (time_is_before_eq_jiffies(
 						xpc_hb_check_timeout) ||
 						xpc_activate_IRQ_rcvd > 0 ||
-						xpc_exiting));
+						xpc_exiting); }));
 	}
 
 	xpc_stop_hb_beater();
@@ -675,9 +676,10 @@ xpc_kthread_waitmsgs(struct xpc_partitio
 		dev_dbg(xpc_chan, "idle kthread calling "
 			"wait_event_interruptible_exclusive()\n");
 
-		(void)wait_event_interruptible_exclusive(ch->idle_wq,
+		(void)wait_event_interruptible_exclusive(ch->idle_wq, ({
+				klp_kgraft_mark_task_safe(current);
 				(n_of_deliverable_payloads(ch) > 0 ||
-				 (ch->flags & XPC_C_DISCONNECTING)));
+				 (ch->flags & XPC_C_DISCONNECTING)); }));
 
 		atomic_dec(&ch->kthreads_idle);
 
--- a/drivers/mmc/card/queue.c
+++ b/drivers/mmc/card/queue.c
@@ -94,6 +94,7 @@ static int mmc_queue_thread(void *d)
 			}
 			up(&mq->thread_sem);
 			schedule();
+			klp_kgraft_mark_task_safe(current);
 			down(&mq->thread_sem);
 		}
 	} while (1);
--- a/drivers/mmc/core/sdio_irq.c
+++ b/drivers/mmc/core/sdio_irq.c
@@ -172,6 +172,7 @@ static int sdio_irq_thread(void *_host)
 			host->ops->enable_sdio_irq(host, 1);
 		if (!kthread_should_stop())
 			schedule_timeout(period);
+		klp_kgraft_mark_task_safe(current);
 		set_current_state(TASK_RUNNING);
 	} while (!kthread_should_stop());
 
--- a/drivers/net/ethernet/qualcomm/qca_spi.c
+++ b/drivers/net/ethernet/qualcomm/qca_spi.c
@@ -521,6 +521,7 @@ qcaspi_spi_thread(void *data)
 			schedule();
 
 		set_current_state(TASK_RUNNING);
+		klp_kgraft_mark_task_safe(current);
 
 		netdev_dbg(qca->net_dev, "have work to do. int: %d, tx_skb: %p\n",
 			   qca->intr_req - qca->intr_svc,
--- a/drivers/net/irda/stir4200.c
+++ b/drivers/net/irda/stir4200.c
@@ -793,7 +793,7 @@ static int stir_transmit_thread(void *ar
 		/* sleep if nothing to send */
                 set_current_state(TASK_INTERRUPTIBLE);
                 schedule();
-
+		klp_kgraft_mark_task_safe(current);
 	}
         return 0;
 }
--- a/drivers/net/wimax/i2400m/usb-rx.c
+++ b/drivers/net/wimax/i2400m/usb-rx.c
@@ -349,10 +349,10 @@ int i2400mu_rxd(void *_i2400mu)
 		d_printf(2, dev, "RX: waiting for messages\n");
 		pending = 0;
 		wait_event_interruptible(
-			i2400mu->rx_wq,
+			i2400mu->rx_wq, ({ klp_kgraft_mark_task_safe(current);
 			(kthread_should_stop()	/* check this first! */
-			 || (pending = atomic_read(&i2400mu->rx_pending_count)))
-			);
+			 || (pending = atomic_read(&i2400mu->rx_pending_count)));
+			}));
 		if (kthread_should_stop())
 			break;
 		if (pending == 0)
--- a/drivers/net/wimax/i2400m/usb-tx.c
+++ b/drivers/net/wimax/i2400m/usb-tx.c
@@ -195,10 +195,10 @@ int i2400mu_txd(void *_i2400mu)
 		d_printf(2, dev, "TX: waiting for messages\n");
 		tx_msg = NULL;
 		wait_event_interruptible(
-			i2400mu->tx_wq,
+			i2400mu->tx_wq, ({ klp_kgraft_mark_task_safe(current);
 			(kthread_should_stop()	/* check this first! */
-			 || (tx_msg = i2400m_tx_msg_get(i2400m, &tx_msg_size)))
-			);
+			 || (tx_msg = i2400m_tx_msg_get(i2400m, &tx_msg_size)));
+			}));
 		if (kthread_should_stop())
 			break;
 		WARN_ON(tx_msg == NULL);	/* should not happen...*/
--- a/drivers/net/wireless/brcm80211/brcmfmac/sdio.c
+++ b/drivers/net/wireless/brcm80211/brcmfmac/sdio.c
@@ -3994,6 +3994,7 @@ brcmf_sdio_watchdog_thread(void *data)
 	/* Run until signal received */
 	brcmf_sdiod_freezer_count(bus->sdiodev);
 	while (1) {
+		klp_kgraft_mark_task_safe(current);
 		if (kthread_should_stop())
 			break;
 		brcmf_sdiod_freezer_uncount(bus->sdiodev);
--- a/drivers/net/wireless/libertas/main.c
+++ b/drivers/net/wireless/libertas/main.c
@@ -466,6 +466,7 @@ static int lbs_thread(void *data)
 		lbs_deb_thread("1: currenttxskb %p, dnld_sent %d\n",
 				priv->currenttxskb, priv->dnld_sent);
 
+		klp_kgraft_mark_task_safe(current);
 		add_wait_queue(&priv->waitq, &wait);
 		set_current_state(TASK_INTERRUPTIBLE);
 		spin_lock_irq(&priv->driver_lock);
--- a/drivers/net/wireless/rsi/rsi_91x_main.c
+++ b/drivers/net/wireless/rsi/rsi_91x_main.c
@@ -170,6 +170,7 @@ static void rsi_tx_scheduler_thread(stru
 	u32 timeout = EVENT_WAIT_FOREVER;
 
 	do {
+		klp_kgraft_mark_task_safe(current);
 		if (adapter->determine_event_timeout)
 			timeout = adapter->determine_event_timeout(adapter);
 		rsi_wait_event(&common->tx_thread.event, timeout);
--- a/drivers/net/wireless/rsi/rsi_91x_usb_ops.c
+++ b/drivers/net/wireless/rsi/rsi_91x_usb_ops.c
@@ -93,6 +93,7 @@ void rsi_usb_rx_thread(struct rsi_common
 	int status;
 
 	do {
+		klp_kgraft_mark_task_safe(current);
 		rsi_wait_event(&dev->rx_thread.event, EVENT_WAIT_FOREVER);
 
 		if (atomic_read(&dev->rx_thread.thread_done))
--- a/drivers/net/xen-netback/netback.c
+++ b/drivers/net/xen-netback/netback.c
@@ -2047,6 +2047,7 @@ static void xenvif_wait_for_rx_work(stru
 	for (;;) {
 		long ret;
 
+		klp_kgraft_mark_task_safe(current);
 		prepare_to_wait(&queue->wq, &wait, TASK_INTERRUPTIBLE);
 		if (xenvif_have_rx_work(queue))
 			break;
@@ -2066,6 +2067,8 @@ int xenvif_kthread_guest_rx(void *data)
 		xenvif_queue_carrier_on(queue);
 
 	for (;;) {
+		klp_kgraft_mark_task_safe(current);
+
 		xenvif_wait_for_rx_work(queue);
 
 		if (kthread_should_stop())
@@ -2129,9 +2132,10 @@ int xenvif_dealloc_kthread(void *data)
 	struct xenvif_queue *queue = data;
 
 	for (;;) {
-		wait_event_interruptible(queue->dealloc_wq,
+		wait_event_interruptible(queue->dealloc_wq, ({
+					 klp_kgraft_mark_task_safe(current);
 					 tx_dealloc_work_todo(queue) ||
-					 xenvif_dealloc_kthread_should_stop(queue));
+					 xenvif_dealloc_kthread_should_stop(queue); }));
 		if (xenvif_dealloc_kthread_should_stop(queue))
 			break;
 
--- a/drivers/parisc/power.c
+++ b/drivers/parisc/power.c
@@ -120,6 +120,7 @@ static int kpowerswd(void *param)
 		int button_not_pressed;
 		unsigned long soft_power_reg = (unsigned long) param;
 
+		klp_kgraft_mark_task_safe(current);
 		schedule_timeout_interruptible(pwrsw_enabled ? HZ : HZ/POWERSWITCH_POLL_PER_SEC);
 
 		if (unlikely(!pwrsw_enabled))
--- a/drivers/pci/hotplug/cpci_hotplug_core.c
+++ b/drivers/pci/hotplug/cpci_hotplug_core.c
@@ -515,6 +515,7 @@ event_thread(void *data)
 		dbg("event thread sleeping");
 		set_current_state(TASK_INTERRUPTIBLE);
 		schedule();
+		klp_kgraft_mark_task_safe(current);
 		if (kthread_should_stop())
 			break;
 		do {
@@ -546,6 +547,7 @@ poll_thread(void *data)
 	int rc;
 
 	while (1) {
+		klp_kgraft_mark_task_safe(current);
 		if (kthread_should_stop() || signal_pending(current))
 			break;
 		if (controller->ops->query_enum()) {
--- a/drivers/pci/hotplug/cpqphp_ctrl.c
+++ b/drivers/pci/hotplug/cpqphp_ctrl.c
@@ -1748,6 +1748,7 @@ static int event_thread(void *data)
 		dbg("!!!!event_thread sleeping\n");
 		set_current_state(TASK_INTERRUPTIBLE);
 		schedule();
+		klp_kgraft_mark_task_safe(current);
 
 		if (kthread_should_stop())
 			break;
--- a/drivers/pci/hotplug/ibmphp_hpc.c
+++ b/drivers/pci/hotplug/ibmphp_hpc.c
@@ -831,6 +831,7 @@ static int poll_hpc(void *data)
 	debug ("%s - Entry\n", __func__);
 
 	while (!kthread_should_stop()) {
+		klp_kgraft_mark_task_safe(current);
 		/* try to get the lock to do some kind of hardware access */
 		down (&semOperations);
 
--- a/drivers/platform/x86/intel_ips.c
+++ b/drivers/platform/x86/intel_ips.c
@@ -812,6 +812,7 @@ static int ips_adjust(void *data)
 			ips_gpu_lower(ips);
 
 sleep:
+		klp_kgraft_mark_task_safe(current);
 		schedule_timeout_interruptible(msecs_to_jiffies(IPS_ADJUST_PERIOD));
 	} while (!kthread_should_stop());
 
@@ -1018,6 +1019,7 @@ static int ips_monitor(void *data)
 			mchp_samples[i] = mchp;
 		}
 
+		klp_kgraft_mark_task_safe(current);
 		schedule_timeout_interruptible(msecs_to_jiffies(IPS_SAMPLE_PERIOD));
 		if (kthread_should_stop())
 			break;
@@ -1107,6 +1109,7 @@ static int ips_monitor(void *data)
 
 		__set_current_state(TASK_INTERRUPTIBLE);
 		mod_timer(&timer, expire);
+		klp_kgraft_mark_task_safe(current);
 		schedule();
 
 		/* Calculate actual sample period for power averaging */
--- a/drivers/s390/cio/crw.c
+++ b/drivers/s390/cio/crw.c
@@ -65,8 +65,9 @@ static int crw_collect_info(void *unused
 	unsigned int chain;
 
 repeat:
-	signal = wait_event_interruptible(crw_handler_wait_q,
-					  atomic_read(&crw_nr_req) > 0);
+	signal = wait_event_interruptible(crw_handler_wait_q, ({
+					  klp_kgraft_mark_task_safe(current);
+					  atomic_read(&crw_nr_req) > 0; }));
 	if (unlikely(signal))
 		atomic_inc(&crw_nr_req);
 	chain = 0;
--- a/drivers/s390/scsi/zfcp_erp.c
+++ b/drivers/s390/scsi/zfcp_erp.c
@@ -1341,9 +1341,10 @@ static int zfcp_erp_thread(void *data)
 	unsigned long flags;
 
 	for (;;) {
-		wait_event_interruptible(adapter->erp_ready_wq,
+		wait_event_interruptible(adapter->erp_ready_wq, ({
+			   klp_kgraft_mark_task_safe(current);
 			   !list_empty(&adapter->erp_ready_head) ||
-			   kthread_should_stop());
+			   kthread_should_stop(); }));
 
 		if (kthread_should_stop())
 			break;
--- a/drivers/sbus/char/bbc_envctrl.c
+++ b/drivers/sbus/char/bbc_envctrl.c
@@ -424,6 +424,7 @@ static int kenvctrld(void *__unused)
 		struct bbc_cpu_temperature *tp;
 		struct bbc_fan_control *fp;
 
+		klp_kgraft_mark_task_safe(current);
 		msleep_interruptible(POLL_INTERVAL);
 		if (kthread_should_stop())
 			break;
--- a/drivers/sbus/char/envctrl.c
+++ b/drivers/sbus/char/envctrl.c
@@ -998,6 +998,7 @@ static int kenvctrld(void *__unused)
 
 	printk(KERN_INFO PFX "%s starting...\n", current->comm);
 	for (;;) {
+		klp_kgraft_mark_task_safe(current);
 		msleep_interruptible(poll_interval);
 
 		if (kthread_should_stop())
--- a/drivers/scsi/aacraid/commsup.c
+++ b/drivers/scsi/aacraid/commsup.c
@@ -1757,6 +1757,8 @@ int aac_command_thread(void *data)
 	set_current_state(TASK_INTERRUPTIBLE);
 	dprintk ((KERN_INFO "aac_command_thread start\n"));
 	while (1) {
+		klp_kgraft_mark_task_safe(current);
+
 		spin_lock_irqsave(dev->queues->queue[HostNormCmdQueue].lock, flags);
 		while(!list_empty(&(dev->queues->queue[HostNormCmdQueue].cmdq))) {
 			struct list_head *entry;
--- a/drivers/scsi/bnx2fc/bnx2fc_fcoe.c
+++ b/drivers/scsi/bnx2fc/bnx2fc_fcoe.c
@@ -635,6 +635,7 @@ int bnx2fc_percpu_io_thread(void *arg)
 	set_current_state(TASK_INTERRUPTIBLE);
 	while (!kthread_should_stop()) {
 		schedule();
+		klp_kgraft_mark_task_safe(current);
 		spin_lock_bh(&p->fp_work_lock);
 		while (!list_empty(&p->work_list)) {
 			list_splice_init(&p->work_list, &work_list);
--- a/drivers/scsi/bnx2i/bnx2i_hwi.c
+++ b/drivers/scsi/bnx2i/bnx2i_hwi.c
@@ -1875,6 +1875,8 @@ int bnx2i_percpu_io_thread(void *arg)
 	set_user_nice(current, MIN_NICE);
 
 	while (!kthread_should_stop()) {
+		klp_kgraft_mark_task_safe(current);
+
 		spin_lock_bh(&p->p_work_lock);
 		while (!list_empty(&p->work_list)) {
 			list_splice_init(&p->work_list, &work_list);
--- a/drivers/scsi/ibmvscsi/ibmvfc.c
+++ b/drivers/scsi/ibmvscsi/ibmvfc.c
@@ -4491,8 +4491,9 @@ static int ibmvfc_work(void *data)
 	set_user_nice(current, MIN_NICE);
 
 	while (1) {
-		rc = wait_event_interruptible(vhost->work_wait_q,
-					      ibmvfc_work_to_do(vhost));
+		rc = wait_event_interruptible(vhost->work_wait_q, ({
+					      klp_kgraft_mark_task_safe(current);
+					      ibmvfc_work_to_do(vhost); }));
 
 		BUG_ON(rc);
 
--- a/drivers/scsi/ibmvscsi/ibmvscsi.c
+++ b/drivers/scsi/ibmvscsi/ibmvscsi.c
@@ -2159,8 +2159,9 @@ static int ibmvscsi_work(void *data)
 	set_user_nice(current, MIN_NICE);
 
 	while (1) {
-		rc = wait_event_interruptible(hostdata->work_wait_q,
-					      ibmvscsi_work_to_do(hostdata));
+		rc = wait_event_interruptible(hostdata->work_wait_q, ({
+					      klp_kgraft_mark_task_safe(current);
+					      ibmvscsi_work_to_do(hostdata); }));
 
 		BUG_ON(rc);
 
--- a/drivers/scsi/lpfc/lpfc_hbadisc.c
+++ b/drivers/scsi/lpfc/lpfc_hbadisc.c
@@ -740,10 +740,11 @@ lpfc_do_work(void *p)
 
 	while (!kthread_should_stop()) {
 		/* wait and check worker queue activities */
-		rc = wait_event_interruptible(phba->work_waitq,
+		rc = wait_event_interruptible(phba->work_waitq, ({
+					klp_kgraft_mark_task_safe(current);
 					(test_and_clear_bit(LPFC_DATA_READY,
 							    &phba->data_flags)
-					 || kthread_should_stop()));
+					 || kthread_should_stop()); }));
 		/* Signal wakeup shall terminate the worker thread */
 		if (rc) {
 			lpfc_printf_log(phba, KERN_ERR, LOG_ELS,
--- a/drivers/scsi/mvumi.c
+++ b/drivers/scsi/mvumi.c
@@ -1646,6 +1646,7 @@ static int mvumi_rescan_bus(void *data)
 	struct mvumi_device *mv_dev = NULL , *dev_next;
 
 	while (!kthread_should_stop()) {
+		klp_kgraft_mark_task_safe(current);
 
 		set_current_state(TASK_INTERRUPTIBLE);
 		if (!atomic_read(&mhba->pnp_count))
--- a/drivers/scsi/qla2xxx/qla_os.c
+++ b/drivers/scsi/qla2xxx/qla_os.c
@@ -4994,6 +4994,7 @@ qla2x00_do_dpc(void *data)
 		    "DPC handler sleeping.\n");
 
 		schedule();
+		klp_kgraft_mark_task_safe(current);
 
 		if (!base_vha->flags.init_done || ha->flags.mbox_busy)
 			goto end_loop;
--- a/drivers/scsi/scsi_error.c
+++ b/drivers/scsi/scsi_error.c
@@ -2204,6 +2204,8 @@ int scsi_error_handler(void *data)
 	 * disables signal delivery for the created thread.
 	 */
 	while (true) {
+		klp_kgraft_mark_task_safe(current);
+
 		/*
 		 * The sequence in kthread_stop() sets the stop flag first
 		 * then wakes the process.  To avoid missed wakeups, the task
--- a/drivers/staging/gdm72xx/gdm_usb.c
+++ b/drivers/staging/gdm72xx/gdm_usb.c
@@ -741,9 +741,10 @@ static int k_mode_thread(void *arg)
 
 			spin_lock_irqsave(&k_lock, flags2);
 		}
-		wait_event_interruptible_lock_irq(k_wait,
+		wait_event_interruptible_lock_irq(k_wait, ({
+						  klp_kgraft_mark_task_safe(current);
 						  !list_empty(&k_list) ||
-						  k_mode_stop, k_lock);
+						  k_mode_stop; }), k_lock);
 		spin_unlock_irqrestore(&k_lock, flags2);
 	}
 	return 0;
--- a/drivers/staging/lustre/lnet/klnds/o2iblnd/o2iblnd_cb.c
+++ b/drivers/staging/lustre/lnet/klnds/o2iblnd/o2iblnd_cb.c
@@ -3164,6 +3164,7 @@ kiblnd_connd(void *arg)
 			continue;
 
 		/* Nothing to do for 'timeout'  */
+		klp_kgraft_mark_task_safe(current);
 		set_current_state(TASK_INTERRUPTIBLE);
 		add_wait_queue(&kiblnd_data.kib_connd_waitq, &wait);
 		spin_unlock_irqrestore(&kiblnd_data.kib_connd_lock, flags);
@@ -3374,6 +3375,7 @@ kiblnd_scheduler(void *arg)
 		if (did_something)
 			continue;
 
+		klp_kgraft_mark_task_safe(current);
 		set_current_state(TASK_INTERRUPTIBLE);
 		add_wait_queue_exclusive(&sched->ibs_waitq, &wait);
 		spin_unlock_irqrestore(&sched->ibs_lock, flags);
@@ -3450,6 +3452,7 @@ kiblnd_failover_thread(void *arg)
 		/* long sleep if no more pending failover */
 		long_sleep = list_empty(&kiblnd_data.kib_failed_devs);
 
+		klp_kgraft_mark_task_safe(current);
 		set_current_state(TASK_INTERRUPTIBLE);
 		add_wait_queue(&kiblnd_data.kib_failover_waitq, &wait);
 		write_unlock_irqrestore(glock, flags);
--- a/drivers/staging/lustre/lnet/klnds/socklnd/socklnd_cb.c
+++ b/drivers/staging/lustre/lnet/klnds/socklnd/socklnd_cb.c
@@ -1531,8 +1531,9 @@ int ksocknal_scheduler(void *arg)
 
 			if (!did_something) {   /* wait for something to do */
 				rc = wait_event_interruptible_exclusive(
-					sched->kss_waitq,
-					!ksocknal_sched_cansleep(sched));
+					sched->kss_waitq, ({
+					klp_kgraft_mark_task_safe(current);
+					!ksocknal_sched_cansleep(sched); }));
 				LASSERT (rc == 0);
 			} else {
 				cond_resched();
@@ -2213,6 +2214,7 @@ ksocknal_connd (void *arg)
 		}
 
 		/* Nothing to do for 'timeout'  */
+		klp_kgraft_mark_task_safe(current);
 		set_current_state(TASK_INTERRUPTIBLE);
 		add_wait_queue_exclusive(&ksocknal_data.ksnd_connd_waitq, &wait);
 		spin_unlock_bh(connd_lock);
@@ -2619,6 +2621,7 @@ ksocknal_reaper (void *arg)
 		    list_empty (&ksocknal_data.ksnd_zombie_conns))
 			schedule_timeout(timeout);
 
+		klp_kgraft_mark_task_safe(current);
 		set_current_state (TASK_RUNNING);
 		remove_wait_queue (&ksocknal_data.ksnd_reaper_waitq, &wait);
 
--- a/drivers/staging/lustre/lnet/lnet/acceptor.c
+++ b/drivers/staging/lustre/lnet/lnet/acceptor.c
@@ -358,6 +358,7 @@ lnet_acceptor(void *arg)
 		return rc;
 
 	while (!lnet_acceptor_state.pta_shutdown) {
+		klp_kgraft_mark_task_safe(current); /* insufficient */
 
 		rc = lnet_sock_accept(&newsock, lnet_acceptor_state.pta_sock);
 		if (rc != 0) {
--- a/drivers/staging/lustre/lnet/lnet/router.c
+++ b/drivers/staging/lustre/lnet/lnet/router.c
@@ -1166,6 +1166,7 @@ lnet_router_checker(void *arg)
 		int cpt;
 		int cpt2;
 
+		klp_kgraft_mark_task_safe(current);
 		cpt = lnet_net_lock_current();
 rescan:
 		version = the_lnet.ln_routers_version;
--- a/drivers/staging/lustre/lnet/selftest/timer.c
+++ b/drivers/staging/lustre/lnet/selftest/timer.c
@@ -172,6 +172,7 @@ stt_timer_main(void *arg)
 	cfs_block_allsigs();
 
 	while (!stt_data.stt_shuttingdown) {
+		klp_kgraft_mark_task_safe(current);
 		stt_check_timers(&stt_data.stt_prev_slot);
 
 		wait_event_timeout(stt_data.stt_waitq,
--- a/drivers/staging/lustre/lustre/ldlm/ldlm_lockd.c
+++ b/drivers/staging/lustre/lustre/ldlm/ldlm_lockd.c
@@ -783,8 +783,9 @@ static int ldlm_bl_thread_main(void *arg
 
 		if (blwi == NULL) {
 			atomic_dec(&blp->blp_busy_threads);
-			l_wait_event_exclusive(blp->blp_waitq,
-					 (blwi = ldlm_bl_get_work(blp)) != NULL,
+			l_wait_event_exclusive(blp->blp_waitq, ({
+					 klp_kgraft_mark_task_safe(current);
+					 (blwi = ldlm_bl_get_work(blp)) != NULL; }),
 					 &lwi);
 			busy = atomic_inc_return(&blp->blp_busy_threads);
 		} else {
--- a/drivers/staging/lustre/lustre/ldlm/ldlm_pool.c
+++ b/drivers/staging/lustre/lustre/ldlm/ldlm_pool.c
@@ -1031,9 +1031,10 @@ static int ldlm_pools_thread_main(void *
 		 */
 		lwi = LWI_TIMEOUT(cfs_time_seconds(c_time),
 				  NULL, NULL);
-		l_wait_event(thread->t_ctl_waitq,
+		l_wait_event(thread->t_ctl_waitq, ({
+			     klp_kgraft_mark_task_safe(current);
 			     thread_is_stopping(thread) ||
-			     thread_is_event(thread),
+			     thread_is_event(thread); }),
 			     &lwi);
 
 		if (thread_test_and_clear_flags(thread, SVC_STOPPING))
--- a/drivers/staging/lustre/lustre/libcfs/tracefile.c
+++ b/drivers/staging/lustre/lustre/libcfs/tracefile.c
@@ -1061,6 +1061,7 @@ end_loop:
 				break;
 			}
 		}
+		klp_kgraft_mark_task_safe(current);
 		init_waitqueue_entry(&__wait, current);
 		add_wait_queue(&tctl->tctl_waitq, &__wait);
 		set_current_state(TASK_INTERRUPTIBLE);
--- a/drivers/staging/lustre/lustre/libcfs/workitem.c
+++ b/drivers/staging/lustre/lustre/libcfs/workitem.c
@@ -285,8 +285,9 @@ cfs_wi_scheduler (void *arg)
 		}
 
 		cfs_wi_sched_unlock(sched);
-		rc = wait_event_interruptible_exclusive(sched->ws_waitq,
-						!cfs_wi_sched_cansleep(sched));
+		rc = wait_event_interruptible_exclusive(sched->ws_waitq, ({
+						klp_kgraft_mark_task_safe(current);
+						!cfs_wi_sched_cansleep(sched); }));
 		cfs_wi_sched_lock(sched);
 	}
 
--- a/drivers/staging/lustre/lustre/llite/llite_close.c
+++ b/drivers/staging/lustre/lustre/llite/llite_close.c
@@ -336,8 +336,9 @@ static int ll_close_thread(void *arg)
 		struct ll_inode_info *lli;
 		struct inode *inode;
 
-		l_wait_event_exclusive(lcq->lcq_waitq,
-				       (lli = ll_close_next_lli(lcq)) != NULL,
+		l_wait_event_exclusive(lcq->lcq_waitq, ({
+				       klp_kgraft_mark_task_safe(current);
+				       (lli = ll_close_next_lli(lcq)) != NULL; }),
 				       &lwi);
 		if (IS_ERR(lli))
 			break;
--- a/drivers/staging/lustre/lustre/llite/lloop.c
+++ b/drivers/staging/lustre/lustre/llite/lloop.c
@@ -428,7 +428,8 @@ static int loop_thread(void *data)
 	up(&lo->lo_sem);
 
 	for (;;) {
-		wait_event(lo->lo_bh_wait, loop_active(lo));
+		wait_event(lo->lo_bh_wait, ({ klp_kgraft_mark_task_safe(current);
+					loop_active(lo); }));
 		if (!atomic_read(&lo->lo_pending)) {
 			int exiting = 0;
 
--- a/drivers/staging/lustre/lustre/llite/statahead.c
+++ b/drivers/staging/lustre/lustre/llite/statahead.c
@@ -972,9 +972,10 @@ static int ll_agl_thread(void *arg)
 	wake_up(&thread->t_ctl_waitq);
 
 	while (1) {
-		l_wait_event(thread->t_ctl_waitq,
+		l_wait_event(thread->t_ctl_waitq, ({
+			     klp_kgraft_mark_task_safe(current);
 			     !agl_list_empty(sai) ||
-			     !thread_is_running(thread),
+			     !thread_is_running(thread); }),
 			     &lwi);
 
 		if (!thread_is_running(thread))
@@ -1193,10 +1194,11 @@ do_it:
 			 */
 			ll_release_page(page, 0);
 			while (1) {
-				l_wait_event(thread->t_ctl_waitq,
+				l_wait_event(thread->t_ctl_waitq, ({
+					     klp_kgraft_mark_task_safe(current);
 					     !sa_received_empty(sai) ||
 					     sai->sai_sent == sai->sai_replied ||
-					     !thread_is_running(thread),
+					     !thread_is_running(thread); }),
 					     &lwi);
 
 				while (!sa_received_empty(sai))
--- a/drivers/staging/lustre/lustre/mgc/mgc_request.c
+++ b/drivers/staging/lustre/lustre/mgc/mgc_request.c
@@ -534,8 +534,8 @@ static int mgc_requeue_thread(void *data
 		to = MGC_TIMEOUT_MIN_SECONDS * HZ;
 		to += rand * HZ / 100; /* rand is centi-seconds */
 		lwi = LWI_TIMEOUT(to, NULL, NULL);
-		l_wait_event(rq_waitq, rq_state & (RQ_STOP | RQ_PRECLEANUP),
-			     &lwi);
+		l_wait_event(rq_waitq, ({ klp_kgraft_mark_task_safe(current);
+				rq_state & (RQ_STOP | RQ_PRECLEANUP); }), &lwi);
 
 		/*
 		 * iterate & processing through the list. for each cld, process
@@ -583,7 +583,8 @@ static int mgc_requeue_thread(void *data
 
 		/* Wait a bit to see if anyone else needs a requeue */
 		lwi = (struct l_wait_info) { 0 };
-		l_wait_event(rq_waitq, rq_state & (RQ_NOW | RQ_STOP),
+		l_wait_event(rq_waitq, ({ klp_kgraft_mark_task_safe(current);
+					rq_state & (RQ_NOW | RQ_STOP); }),
 			     &lwi);
 		spin_lock(&config_list_lock);
 	}
--- a/drivers/staging/lustre/lustre/obdclass/genops.c
+++ b/drivers/staging/lustre/lustre/obdclass/genops.c
@@ -1270,8 +1270,8 @@ static int obd_zombie_impexp_thread(void
 	while (!test_bit(OBD_ZOMBIE_STOP, &obd_zombie_flags)) {
 		struct l_wait_info lwi = { 0 };
 
-		l_wait_event(obd_zombie_waitq,
-			     !obd_zombie_impexp_check(NULL), &lwi);
+		l_wait_event(obd_zombie_waitq, ({ klp_kgraft_mark_task_safe(current);
+			     !obd_zombie_impexp_check(NULL); }), &lwi);
 		obd_zombie_impexp_cull();
 
 		/*
--- a/drivers/staging/lustre/lustre/ptlrpc/import.c
+++ b/drivers/staging/lustre/lustre/ptlrpc/import.c
@@ -309,8 +309,9 @@ void ptlrpc_invalidate_import(struct obd
 			cfs_timeout_cap(cfs_time_seconds(timeout)),
 			(timeout > 1)?cfs_time_seconds(1):cfs_time_seconds(1)/2,
 			NULL, NULL);
-		rc = l_wait_event(imp->imp_recovery_waitq,
-				  (atomic_read(&imp->imp_inflight) == 0),
+		rc = l_wait_event(imp->imp_recovery_waitq, ({
+				  klp_kgraft_mark_task_safe(current);
+				  (atomic_read(&imp->imp_inflight) == 0); }),
 				  &lwi);
 		if (rc) {
 			const char *cli_tgt = obd2cli_tgt(imp->imp_obd);
--- a/drivers/staging/lustre/lustre/ptlrpc/pinger.c
+++ b/drivers/staging/lustre/lustre/ptlrpc/pinger.c
@@ -270,9 +270,10 @@ static int ptlrpc_pinger_main(void *arg)
 			lwi = LWI_TIMEOUT(max_t(long, time_to_next_wake,
 						cfs_time_seconds(1)),
 					  NULL, NULL);
-			l_wait_event(thread->t_ctl_waitq,
+			l_wait_event(thread->t_ctl_waitq, ({
+				     klp_kgraft_mark_task_safe(current);
 				     thread_is_stopping(thread) ||
-				     thread_is_event(thread),
+				     thread_is_event(thread); }),
 				     &lwi);
 			if (thread_test_and_clear_flags(thread, SVC_STOPPING))
 				break;
--- a/drivers/staging/lustre/lustre/ptlrpc/ptlrpcd.c
+++ b/drivers/staging/lustre/lustre/ptlrpc/ptlrpcd.c
@@ -436,8 +436,9 @@ static int ptlrpcd(void *arg)
 				  ptlrpc_expired_set, set);
 
 		lu_context_enter(&env.le_ctx);
-		l_wait_event(set->set_waitq,
-			     ptlrpcd_check(&env, pc), &lwi);
+		l_wait_event(set->set_waitq, ({
+			     klp_kgraft_mark_task_safe(current);
+			     ptlrpcd_check(&env, pc); }), &lwi);
 		lu_context_exit(&env.le_ctx);
 
 		/*
--- a/drivers/staging/lustre/lustre/ptlrpc/sec_gc.c
+++ b/drivers/staging/lustre/lustre/ptlrpc/sec_gc.c
@@ -185,9 +185,10 @@ again:
 		sec_process_ctx_list();
 
 		lwi = LWI_TIMEOUT(SEC_GC_INTERVAL * HZ, NULL, NULL);
-		l_wait_event(thread->t_ctl_waitq,
+		l_wait_event(thread->t_ctl_waitq, ({
+			     klp_kgraft_mark_task_safe(current);
 			     thread_is_stopping(thread) ||
-			     thread_is_signal(thread),
+			     thread_is_signal(thread); }),
 			     &lwi);
 
 		if (thread_test_and_clear_flags(thread, SVC_STOPPING))
--- a/drivers/staging/lustre/lustre/ptlrpc/service.c
+++ b/drivers/staging/lustre/lustre/ptlrpc/service.c
@@ -1954,12 +1954,13 @@ ptlrpc_wait_event(struct ptlrpc_service_
 
 	cond_resched();
 
-	l_wait_event_exclusive_head(svcpt->scp_waitq,
+	l_wait_event_exclusive_head(svcpt->scp_waitq, ({
+				klp_kgraft_mark_task_safe(current);
 				ptlrpc_thread_stopping(thread) ||
 				ptlrpc_server_request_incoming(svcpt) ||
 				ptlrpc_server_request_pending(svcpt, false) ||
 				ptlrpc_rqbd_pending(svcpt) ||
-				ptlrpc_at_check(svcpt), &lwi);
+				ptlrpc_at_check(svcpt); }), &lwi);
 
 	if (ptlrpc_thread_stopping(thread))
 		return -EINTR;
@@ -2201,7 +2202,8 @@ static int ptlrpc_hr_main(void *arg)
 	wake_up(&ptlrpc_hr.hr_waitq);
 
 	while (!ptlrpc_hr.hr_stopping) {
-		l_wait_condition(hrt->hrt_waitq, hrt_dont_sleep(hrt, &replies));
+		l_wait_condition(hrt->hrt_waitq, ({ klp_kgraft_mark_task_safe(current);
+					hrt_dont_sleep(hrt, &replies); }));
 
 		while (!list_empty(&replies)) {
 			struct ptlrpc_reply_state *rs;
--- a/drivers/staging/media/lirc/lirc_zilog.c
+++ b/drivers/staging/media/lirc/lirc_zilog.c
@@ -345,6 +345,7 @@ static int add_to_buf(struct IR *ir)
 	 * data and we have space
 	 */
 	do {
+		klp_kgraft_mark_task_safe(current);
 		if (kthread_should_stop()) {
 			ret = -ENODATA;
 			break;
@@ -468,6 +469,7 @@ static int lirc_thread(void *arg)
 	dev_dbg(ir->l.dev, "poll thread started\n");
 
 	while (!kthread_should_stop()) {
+		klp_kgraft_mark_task_safe(current);
 		set_current_state(TASK_INTERRUPTIBLE);
 
 		/* if device not opened, we can sleep half a second */
--- a/drivers/staging/most/aim-sound/sound.c
+++ b/drivers/staging/most/aim-sound/sound.c
@@ -237,11 +237,12 @@ static int playback_thread(void *data)
 		int ret;
 
 		wait_event_interruptible(
-			channel->playback_waitq,
+			channel->playback_waitq, ({
+			klp_kgraft_mark_task_safe(current);
 			kthread_should_stop() ||
 			(channel->is_stream_running &&
 			 (mbo = most_get_mbo(channel->iface, channel->id,
-					     &audio_aim))));
+					     &audio_aim))); }));
 		if (!mbo)
 			continue;
 
--- a/drivers/staging/most/hdm-dim2/dim2_hdm.c
+++ b/drivers/staging/most/hdm-dim2/dim2_hdm.c
@@ -281,9 +281,10 @@ static int deliver_netinfo_thread(void *
 	struct dim2_hdm *dev = data;
 
 	while (!kthread_should_stop()) {
-		wait_event_interruptible(dev->netinfo_waitq,
+		wait_event_interruptible(dev->netinfo_waitq, ({
+					 klp_kgraft_mark_task_safe(current);
 					 dev->deliver_netinfo ||
-					 kthread_should_stop());
+					 kthread_should_stop(); }));
 
 		if (dev->deliver_netinfo) {
 			dev->deliver_netinfo--;
--- a/drivers/staging/most/mostcore/core.c
+++ b/drivers/staging/most/mostcore/core.c
@@ -1183,9 +1183,10 @@ static int hdm_enqueue_thread(void *data
 	typeof(c->iface->enqueue) enqueue = c->iface->enqueue;
 
 	while (likely(!kthread_should_stop())) {
-		wait_event_interruptible(c->hdm_fifo_wq,
+		wait_event_interruptible(c->hdm_fifo_wq, ({
+					 klp_kgraft_mark_task_safe(current);
 					 (mbo = get_hdm_mbo(c)) ||
-					 kthread_should_stop());
+					 kthread_should_stop(); }));
 
 		if (unlikely(!mbo))
 			continue;
--- a/drivers/staging/rtl8188eu/core/rtw_cmd.c
+++ b/drivers/staging/rtl8188eu/core/rtw_cmd.c
@@ -178,6 +178,7 @@ int rtw_cmd_thread(void *context)
 	RT_TRACE(_module_rtl871x_cmd_c_, _drv_info_, ("start r871x rtw_cmd_thread !!!!\n"));
 
 	while (1) {
+		klp_kgraft_mark_task_safe(current);
 		if (_rtw_down_sema(&pcmdpriv->cmd_queue_sema) == _FAIL)
 			break;
 
--- a/drivers/staging/rtl8712/rtl8712_cmd.c
+++ b/drivers/staging/rtl8712/rtl8712_cmd.c
@@ -322,6 +322,7 @@ int r8712_cmd_thread(void *context)
 
 	allow_signal(SIGTERM);
 	while (1) {
+		klp_kgraft_mark_task_safe(current);
 		if ((_down_sema(&(pcmdpriv->cmd_queue_sema))) == _FAIL)
 			break;
 		if (padapter->bDriverStopped || padapter->bSurpriseRemoved)
--- a/drivers/staging/rts5208/rtsx.c
+++ b/drivers/staging/rts5208/rtsx.c
@@ -416,6 +416,7 @@ static int rtsx_control_thread(void *__d
 	struct Scsi_Host *host = rtsx_to_host(dev);
 
 	for (;;) {
+		klp_kgraft_mark_task_safe(current);
 		if (wait_for_completion_interruptible(&dev->cmnd_ready))
 			break;
 
@@ -535,6 +536,7 @@ static int rtsx_polling_thread(void *__d
 
 	for (;;) {
 
+		klp_kgraft_mark_task_safe(current);
 		set_current_state(TASK_INTERRUPTIBLE);
 		schedule_timeout(msecs_to_jiffies(POLLING_INTERVAL));
 
--- a/drivers/staging/speakup/thread.c
+++ b/drivers/staging/speakup/thread.c
@@ -23,6 +23,7 @@ int speakup_thread(void *data)
 		DEFINE_WAIT(wait);
 
 		while (1) {
+			klp_kgraft_mark_task_safe(current);
 			spin_lock_irqsave(&speakup_info.spinlock, flags);
 			our_sound = spk_unprocessed_sound;
 			spk_unprocessed_sound.active = 0;
--- a/drivers/staging/unisys/visorhba/visorhba_main.c
+++ b/drivers/staging/unisys/visorhba/visorhba_main.c
@@ -1021,8 +1021,9 @@ static int process_incoming_rsps(void *v
 		if (kthread_should_stop())
 			break;
 		wait_event_interruptible_timeout(
-			devdata->rsp_queue, (atomic_read(
-					     &devdata->interrupt_rcvd) == 1),
+			devdata->rsp_queue, ({
+				klp_kgraft_mark_task_safe(current);
+				(atomic_read(&devdata->interrupt_rcvd) == 1); }),
 				msecs_to_jiffies(devdata->thread_wait_ms));
 		/* drain queue */
 		drain_queue(cmdrsp, devdata);
--- a/drivers/staging/wilc1000/host_interface.c
+++ b/drivers/staging/wilc1000/host_interface.c
@@ -2813,6 +2813,8 @@ static int hostIFthread(void *pvArg)
 	memset(&msg, 0, sizeof(struct host_if_msg));
 
 	while (1) {
+		klp_kgraft_mark_task_safe(current); /* insufficient */
+
 		wilc_mq_recv(&hif_msg_q, &msg, sizeof(struct host_if_msg), &u32Ret);
 		hif_drv = (struct host_if_drv *)msg.drv;
 		if (msg.id == HOST_IF_MSG_EXIT) {
--- a/drivers/staging/wilc1000/linux_wlan.c
+++ b/drivers/staging/wilc1000/linux_wlan.c
@@ -457,6 +457,7 @@ static int linux_wlan_txq_task(void *vp)
 	/* inform wilc1000_wlan_init that TXQ task is started. */
 	up(&wl->txq_thread_started);
 	while (1) {
+		klp_kgraft_mark_task_safe(current); /* insufficient */
 
 		PRINT_D(TX_DBG, "txq_task Taking a nap :)\n");
 		down(&wl->txq_event);
--- a/drivers/target/iscsi/iscsi_target.c
+++ b/drivers/target/iscsi/iscsi_target.c
@@ -3800,8 +3800,10 @@ int iscsi_target_tx_thread(void *arg)
 		 */
 		iscsit_thread_check_cpumask(conn, current, 1);
 
-		wait_event_interruptible(conn->queues_wq,
-					 !iscsit_conn_all_queues_empty(conn));
+		wait_event_interruptible(conn->queues_wq, ({
+					 klp_kgraft_mark_task_safe(current);
+					 !iscsit_conn_all_queues_empty(conn);
+					 }));
 
 		if (signal_pending(current))
 			goto transport_err;
@@ -3928,6 +3930,7 @@ static void iscsit_get_rx_pdu(struct isc
 	struct kvec iov;
 
 	while (!kthread_should_stop()) {
+		klp_kgraft_mark_task_safe(current);
 		/*
 		 * Ensure that both TX and RX per connection kthreads
 		 * are scheduled to run on the same CPU.
--- a/drivers/target/iscsi/iscsi_target_login.c
+++ b/drivers/target/iscsi/iscsi_target_login.c
@@ -1450,6 +1450,7 @@ int iscsi_target_login_thread(void *arg)
 	allow_signal(SIGINT);
 
 	while (1) {
+		klp_kgraft_mark_task_safe(current);
 		ret = __iscsi_target_login_thread(np);
 		/*
 		 * We break and exit here unless another sock_accept() call
--- a/drivers/tty/bfin_jtag_comm.c
+++ b/drivers/tty/bfin_jtag_comm.c
@@ -72,6 +72,9 @@ bfin_jc_emudat_manager(void *arg)
 
 	while (!kthread_should_stop()) {
 		struct tty_struct *tty = tty_port_tty_get(&port);
+
+		klp_kgraft_mark_task_safe(current);
+
 		/* no one left to give data to, so sleep */
 		if (tty == NULL && circ_empty(&bfin_jc_write_buf)) {
 			pr_debug("waiting for readers\n");
--- a/drivers/tty/hvc/hvcs.c
+++ b/drivers/tty/hvc/hvcs.c
@@ -647,6 +647,7 @@ static int khvcsd(void *unused)
 	__set_current_state(TASK_RUNNING);
 
 	do {
+		klp_kgraft_mark_task_safe(current);
 		hvcs_todo_mask = 0;
 		hvcs_kicked = 0;
 		wmb();
--- a/drivers/tty/metag_da.c
+++ b/drivers/tty/metag_da.c
@@ -299,8 +299,9 @@ static int put_data(void *arg)
 		if (stall)
 			msleep(25);
 
-		wait_event_interruptible(dashtty_waitqueue,
-					 atomic_read(&dashtty_xmit_cnt));
+		wait_event_interruptible(dashtty_waitqueue, ({
+					 klp_kgraft_mark_task_safe(current);
+					 atomic_read(&dashtty_xmit_cnt); }));
 	}
 
 	return 0;
--- a/drivers/tty/mips_ejtag_fdc.c
+++ b/drivers/tty/mips_ejtag_fdc.c
@@ -492,9 +492,10 @@ static int mips_ejtag_fdc_put(void *arg)
 	__set_current_state(TASK_RUNNING);
 	while (!kthread_should_stop()) {
 		/* Wait for data to actually write */
-		wait_event_interruptible(priv->waitqueue,
+		wait_event_interruptible(priv->waitqueue, ({
+					 klp_kgraft_mark_task_safe(current);
 					 atomic_read(&priv->xmit_total) ||
-					 kthread_should_stop());
+					 kthread_should_stop(); }));
 		if (kthread_should_stop())
 			break;
 
@@ -511,10 +512,11 @@ static int mips_ejtag_fdc_put(void *arg)
 			}
 		}
 		raw_spin_unlock_irq(&priv->lock);
-		wait_event_interruptible(priv->waitqueue,
+		wait_event_interruptible(priv->waitqueue, ({
+					 klp_kgraft_mark_task_safe(current);
 					 !(mips_ejtag_fdc_read(priv, REG_FDSTAT)
 					   & REG_FDSTAT_TXF) ||
-					 kthread_should_stop());
+					 kthread_should_stop(); }));
 		if (kthread_should_stop())
 			break;
 
--- a/drivers/usb/early/ehci-dbgp.c
+++ b/drivers/usb/early/ehci-dbgp.c
@@ -1070,6 +1070,7 @@ static int kgdbdbgp_reader_thread(void *
 	int ret;
 
 	while (readl(&ehci_debug->control) & DBGP_ENABLED) {
+		klp_kgraft_mark_task_safe(current);
 		kgdbdbgp_loop_cnt = 1;
 		ret = kgdbdbgp_read_char();
 		kgdbdbgp_loop_cnt = DBGP_LOOPS;
--- a/drivers/usb/host/max3421-hcd.c
+++ b/drivers/usb/host/max3421-hcd.c
@@ -1407,6 +1407,7 @@ max3421_spi_thread(void *dev_id)
 		 BIT(MAX3421_PINCTL_INTLEVEL_BIT)));	/* low-active irq */
 
 	while (!kthread_should_stop()) {
+		klp_kgraft_mark_task_safe(current);
 		max3421_hcd->rev = spi_rd8(hcd, MAX3421_REG_REVISION);
 		if (max3421_hcd->rev == 0x12 || max3421_hcd->rev == 0x13)
 			break;
@@ -1418,6 +1419,7 @@ max3421_spi_thread(void *dev_id)
 		 spi->irq);
 
 	while (!kthread_should_stop()) {
+		klp_kgraft_mark_task_safe(current);
 		if (!i_worked) {
 			/*
 			 * We'll be waiting for wakeups from the hard
--- a/drivers/usb/storage/usb.c
+++ b/drivers/usb/storage/usb.c
@@ -308,10 +308,19 @@ static int usb_stor_control_thread(void
 	struct Scsi_Host *host = us_to_host(us);
 
 	for (;;) {
+		long to;
+
 		usb_stor_dbg(us, "*** thread sleeping\n");
-		if (wait_for_completion_interruptible(&us->cmnd_ready))
+		to = wait_for_completion_interruptible_timeout(&us->cmnd_ready,
+				HZ * 3);
+		if (to < 0)
 			break;
 
+		if (!to) {
+			klp_kgraft_mark_task_safe(current);
+			continue;
+		}
+
 		usb_stor_dbg(us, "*** thread awakened\n");
 
 		/* lock the device pointers */
--- a/drivers/usb/usbip/stub_rx.c
+++ b/drivers/usb/usbip/stub_rx.c
@@ -584,6 +584,7 @@ int stub_rx_loop(void *data)
 	struct usbip_device *ud = data;
 
 	while (!kthread_should_stop()) {
+		klp_kgraft_mark_task_safe(current);
 		if (usbip_event_happened(ud))
 			break;
 
--- a/drivers/usb/usbip/stub_tx.c
+++ b/drivers/usb/usbip/stub_tx.c
@@ -388,10 +388,11 @@ int stub_tx_loop(void *data)
 		if (stub_send_ret_unlink(sdev) < 0)
 			break;
 
-		wait_event_interruptible(sdev->tx_waitq,
+		wait_event_interruptible(sdev->tx_waitq, ({
+					 klp_kgraft_mark_task_safe(current);
 					 (!list_empty(&sdev->priv_tx) ||
 					  !list_empty(&sdev->unlink_tx) ||
-					  kthread_should_stop()));
+					  kthread_should_stop()); }));
 	}
 
 	return 0;
--- a/drivers/usb/usbip/usbip_event.c
+++ b/drivers/usb/usbip/usbip_event.c
@@ -66,9 +66,10 @@ static int event_handler_loop(void *data
 	struct usbip_device *ud = data;
 
 	while (!kthread_should_stop()) {
-		wait_event_interruptible(ud->eh_waitq,
+		wait_event_interruptible(ud->eh_waitq, ({
+					 klp_kgraft_mark_task_safe(current);
 					 usbip_event_happened(ud) ||
-					 kthread_should_stop());
+					 kthread_should_stop(); }));
 		usbip_dbg_eh("wakeup\n");
 
 		if (event_handler(ud) < 0)
--- a/drivers/usb/usbip/vhci_rx.c
+++ b/drivers/usb/usbip/vhci_rx.c
@@ -258,6 +258,7 @@ int vhci_rx_loop(void *data)
 	struct usbip_device *ud = data;
 
 	while (!kthread_should_stop()) {
+		klp_kgraft_mark_task_safe(current);
 		if (usbip_event_happened(ud))
 			break;
 
--- a/drivers/usb/usbip/vhci_tx.c
+++ b/drivers/usb/usbip/vhci_tx.c
@@ -212,10 +212,11 @@ int vhci_tx_loop(void *data)
 		if (vhci_send_cmd_unlink(vdev) < 0)
 			break;
 
-		wait_event_interruptible(vdev->waitq_tx,
+		wait_event_interruptible(vdev->waitq_tx, ({
+					 klp_kgraft_mark_task_safe(current);
 					 (!list_empty(&vdev->priv_tx) ||
 					  !list_empty(&vdev->unlink_tx) ||
-					  kthread_should_stop()));
+					  kthread_should_stop()); }));
 
 		usbip_dbg_vhci_tx("pending urbs ?, now wake up\n");
 	}
--- a/drivers/uwb/uwbd.c
+++ b/drivers/uwb/uwbd.c
@@ -273,9 +273,10 @@ static int uwbd(void *param)
 
 	while (1) {
 		wait_event_interruptible_timeout(
-			rc->uwbd.wq,
+			rc->uwbd.wq, ({
+			klp_kgraft_mark_task_safe(current);
 			!list_empty(&rc->uwbd.event_list)
-			  || (should_stop = kthread_should_stop()),
+			  || (should_stop = kthread_should_stop()); }),
 			HZ);
 		if (should_stop)
 			break;
--- a/drivers/vhost/vhost.c
+++ b/drivers/vhost/vhost.c
@@ -291,6 +291,7 @@ static int vhost_worker(void *data)
 	use_mm(dev->mm);
 
 	for (;;) {
+		klp_kgraft_mark_task_safe(current);
 		/* mb paired w/ kthread_stop */
 		set_current_state(TASK_INTERRUPTIBLE);
 
--- a/drivers/virtio/virtio_balloon.c
+++ b/drivers/virtio/virtio_balloon.c
@@ -370,6 +370,8 @@ static int balloon(void *_vballoon)
 
 		add_wait_queue(&vb->config_change, &wait);
 		for (;;) {
+			klp_kgraft_mark_task_safe(current);
+
 			if ((diff = towards_target(vb)) != 0 ||
 			    vb->need_stats_update ||
 			    kthread_should_stop() ||
--- a/drivers/xen/xenbus/xenbus_xs.c
+++ b/drivers/xen/xenbus/xenbus_xs.c
@@ -806,8 +806,9 @@ static int xenwatch_thread(void *unused)
 	struct xs_stored_msg *msg;
 
 	for (;;) {
-		wait_event_interruptible(watch_events_waitq,
-					 !list_empty(&watch_events));
+		wait_event_interruptible(watch_events_waitq, ({
+					 klp_kgraft_mark_task_safe(current);
+					 !list_empty(&watch_events); }));
 
 		if (kthread_should_stop())
 			break;
--- a/fs/btrfs/inode-map.c
+++ b/fs/btrfs/inode-map.c
@@ -54,6 +54,7 @@ static int caching_kthread(void *data)
 	key.offset = 0;
 	key.type = BTRFS_INODE_ITEM_KEY;
 again:
+	klp_kgraft_mark_task_safe(current);
 	/* need to make sure the commit_root doesn't disappear */
 	down_read(&fs_info->commit_root_sem);
 
--- a/fs/cifs/connect.c
+++ b/fs/cifs/connect.c
@@ -950,6 +950,7 @@ cifs_demultiplex_thread(void *p)
 	if (!task_to_wake) {
 		set_current_state(TASK_INTERRUPTIBLE);
 		while (!signal_pending(current)) {
+			klp_kgraft_mark_task_safe(current);
 			schedule();
 			set_current_state(TASK_INTERRUPTIBLE);
 		}
--- a/fs/cifs/transport.c
+++ b/fs/cifs/transport.c
@@ -497,8 +497,9 @@ wait_for_response(struct TCP_Server_Info
 {
 	int error;
 
-	error = wait_event_freezekillable_unsafe(server->response_q,
-				    midQ->mid_state != MID_REQUEST_SUBMITTED);
+	error = wait_event_freezekillable_unsafe(server->response_q, ({
+				    klp_kgraft_mark_task_safe(current);
+				    midQ->mid_state != MID_REQUEST_SUBMITTED; }));
 	if (error < 0)
 		return -ERESTARTSYS;
 
--- a/fs/dlm/lockspace.c
+++ b/fs/dlm/lockspace.c
@@ -278,6 +278,7 @@ static int dlm_scand(void *data)
 	struct dlm_ls *ls;
 
 	while (!kthread_should_stop()) {
+		klp_kgraft_mark_task_safe(current);
 		ls = find_ls_to_scan();
 		if (ls) {
 			if (dlm_lock_recovery_try(ls)) {
--- a/fs/dlm/recoverd.c
+++ b/fs/dlm/recoverd.c
@@ -288,6 +288,7 @@ static int dlm_recoverd(void *arg)
 	wake_up(&ls->ls_recover_lock_wait);
 
 	while (!kthread_should_stop()) {
+		klp_kgraft_mark_task_safe(current);
 		set_current_state(TASK_INTERRUPTIBLE);
 		if (!test_bit(LSFL_RECOVER_WORK, &ls->ls_flags) &&
 		    !test_bit(LSFL_RECOVER_DOWN, &ls->ls_flags))
--- a/fs/ecryptfs/kthread.c
+++ b/fs/ecryptfs/kthread.c
@@ -60,9 +60,10 @@ static int ecryptfs_threadfn(void *ignor
 		struct ecryptfs_open_req *req;
 
 		wait_event_freezable(
-			ecryptfs_kthread_ctl.wait,
+			ecryptfs_kthread_ctl.wait, ({
+			klp_kgraft_mark_task_safe(current);
 			(!list_empty(&ecryptfs_kthread_ctl.req_list)
-			 || kthread_should_stop()));
+			 || kthread_should_stop()); }));
 		mutex_lock(&ecryptfs_kthread_ctl.mux);
 		if (ecryptfs_kthread_ctl.flags & ECRYPTFS_KTHREAD_ZOMBIE) {
 			mutex_unlock(&ecryptfs_kthread_ctl.mux);
--- a/fs/ext4/mmp.c
+++ b/fs/ext4/mmp.c
@@ -159,6 +159,7 @@ static int kmmpd(void *data)
 	       sizeof(mmp->mmp_nodename));
 
 	while (!kthread_should_stop()) {
+		klp_kgraft_mark_task_safe(current);
 		if (++seq > EXT4_MMP_SEQ_MAX)
 			seq = 1;
 
--- a/fs/f2fs/segment.c
+++ b/fs/f2fs/segment.c
@@ -345,8 +345,9 @@ repeat:
 		fcc->dispatch_list = NULL;
 	}
 
-	wait_event_interruptible(*q,
-		kthread_should_stop() || !llist_empty(&fcc->issue_list));
+	wait_event_interruptible(*q, ({
+		klp_kgraft_mark_task_safe(current);
+		kthread_should_stop() || !llist_empty(&fcc->issue_list); }));
 	goto repeat;
 }
 
--- a/fs/jbd2/journal.c
+++ b/fs/jbd2/journal.c
@@ -43,6 +43,7 @@
 #include <linux/backing-dev.h>
 #include <linux/bitops.h>
 #include <linux/ratelimit.h>
+#include <linux/sched.h>
 
 #define CREATE_TRACE_POINTS
 #include <trace/events/jbd2.h>
@@ -260,6 +261,7 @@ loop:
 			write_lock(&journal->j_state_lock);
 		}
 		finish_wait(&journal->j_wait_commit, &wait);
+		klp_kgraft_mark_task_safe(current);
 	}
 
 	jbd_debug(1, "kjournald2 wakes\n");
--- a/fs/jffs2/background.c
+++ b/fs/jffs2/background.c
@@ -89,6 +89,7 @@ static int jffs2_garbage_collect_thread(
 
 	set_freezable();
 	for (;;) {
+		klp_kgraft_mark_task_safe(current);
 		sigprocmask(SIG_UNBLOCK, &hupmask, NULL);
 	again:
 		spin_lock(&c->erase_completion_lock);
--- a/fs/jfs/jfs_logmgr.c
+++ b/fs/jfs/jfs_logmgr.c
@@ -2336,6 +2336,7 @@ int jfsIOWait(void *arg)
 	struct lbuf *bp;
 
 	do {
+		klp_kgraft_mark_task_safe(current);
 		spin_lock_irq(&log_redrive_lock);
 		while ((bp = log_redrive_list)) {
 			log_redrive_list = bp->l_redrive_next;
--- a/fs/jfs/jfs_txnmgr.c
+++ b/fs/jfs/jfs_txnmgr.c
@@ -2752,6 +2752,7 @@ int jfs_lazycommit(void *arg)
 	struct jfs_sb_info *sbi;
 
 	do {
+		klp_kgraft_mark_task_safe(current);
 		LAZY_LOCK(flags);
 		jfs_commit_thread_waking = 0;	/* OK to wake another thread */
 		while (!list_empty(&TxAnchor.unlock_queue)) {
@@ -2935,6 +2936,7 @@ int jfs_sync(void *arg)
 	tid_t tid;
 
 	do {
+		klp_kgraft_mark_task_safe(current);
 		/*
 		 * write each inode on the anonymous inode list
 		 */
--- a/fs/nilfs2/segment.c
+++ b/fs/nilfs2/segment.c
@@ -2547,6 +2547,7 @@ static int nilfs_segctor_thread(void *ar
 
 	spin_lock(&sci->sc_state_lock);
  loop:
+	klp_kgraft_mark_task_safe(current);
 	for (;;) {
 		int mode;
 
--- a/fs/ocfs2/cluster/heartbeat.c
+++ b/fs/ocfs2/cluster/heartbeat.c
@@ -1089,6 +1089,7 @@ static int o2hb_thread(void *data)
 
 	while (!kthread_should_stop() &&
 	       !reg->hr_unclean_stop && !reg->hr_aborted_start) {
+		klp_kgraft_mark_task_safe(current);
 		/* We track the time spent inside
 		 * o2hb_do_disk_heartbeat so that we avoid more than
 		 * hr_timeout_ms between disk writes. On busy systems
--- a/fs/ocfs2/dlm/dlmrecovery.c
+++ b/fs/ocfs2/dlm/dlmrecovery.c
@@ -317,8 +317,9 @@ static int dlm_recovery_thread(void *dat
 				mlog_errno(status);
 		}
 
-		wait_event_interruptible_timeout(dlm->dlm_reco_thread_wq,
-						 kthread_should_stop(),
+		wait_event_interruptible_timeout(dlm->dlm_reco_thread_wq, ({
+						 klp_kgraft_mark_task_safe(current);
+						 kthread_should_stop(); }),
 						 timeout);
 	}
 
@@ -732,8 +733,9 @@ static int dlm_remaster_locks(struct dlm
 		}
 		/* wait to be signalled, with periodic timeout
 		 * to check for node death */
-		wait_event_interruptible_timeout(dlm->dlm_reco_thread_wq,
-					 kthread_should_stop(),
+		wait_event_interruptible_timeout(dlm->dlm_reco_thread_wq, ({
+					 klp_kgraft_mark_task_safe(current);
+					 kthread_should_stop(); }),
 					 msecs_to_jiffies(DLM_RECO_THREAD_TIMEOUT_MS));
 
 	}
--- a/fs/ocfs2/dlm/dlmthread.c
+++ b/fs/ocfs2/dlm/dlmthread.c
@@ -756,9 +756,10 @@ in_progress:
 			continue;
 		}
 
-		wait_event_interruptible_timeout(dlm->dlm_thread_wq,
+		wait_event_interruptible_timeout(dlm->dlm_thread_wq, ({
+						 klp_kgraft_mark_task_safe(current);
 						 !dlm_dirty_list_empty(dlm) ||
-						 kthread_should_stop(),
+						 kthread_should_stop(); }),
 						 timeout);
 	}
 
--- a/fs/ocfs2/dlmglue.c
+++ b/fs/ocfs2/dlmglue.c
@@ -4089,9 +4089,10 @@ static int ocfs2_downconvert_thread(void
 	while (!(kthread_should_stop() &&
 		ocfs2_downconvert_thread_lists_empty(osb))) {
 
-		wait_event_interruptible(osb->dc_event,
+		wait_event_interruptible(osb->dc_event, ({
+					 klp_kgraft_mark_task_safe(current);
 					 ocfs2_downconvert_thread_should_wake(osb) ||
-					 kthread_should_stop());
+					 kthread_should_stop(); }));
 
 		mlog(0, "downconvert_thread: awoken\n");
 
--- a/fs/ocfs2/journal.c
+++ b/fs/ocfs2/journal.c
@@ -2293,9 +2293,10 @@ static int ocfs2_commit_thread(void *arg
 	while (!(kthread_should_stop() &&
 		 atomic_read(&journal->j_num_trans) == 0)) {
 
-		wait_event_interruptible(osb->checkpoint_event,
+		wait_event_interruptible(osb->checkpoint_event, ({
+					 klp_kgraft_mark_task_safe(current);
 					 atomic_read(&journal->j_num_trans)
-					 || kthread_should_stop());
+					 || kthread_should_stop(); }));
 
 		status = ocfs2_commit_cache(osb);
 		if (status < 0) {
--- a/fs/xfs/xfs_trans_ail.c
+++ b/fs/xfs/xfs_trans_ail.c
@@ -499,6 +499,8 @@ xfsaild(
 	current->flags |= PF_MEMALLOC;
 
 	while (!kthread_should_stop()) {
+		klp_kgraft_mark_task_safe(current);
+
 		if (tout && tout <= 20)
 			__set_current_state(TASK_KILLABLE);
 		else
--- a/include/linux/freezer.h
+++ b/include/linux/freezer.h
@@ -61,6 +61,9 @@ static inline bool try_to_freeze_unsafe(
 
 static inline bool try_to_freeze(void)
 {
+	if (current->flags & PF_KTHREAD)
+		klp_kgraft_mark_task_safe(current);
+
 	if (!(current->flags & PF_NOFREEZE))
 		debug_check_no_locks_held();
 	return try_to_freeze_unsafe();
@@ -268,7 +271,13 @@ static inline void thaw_processes(void)
 static inline void thaw_kernel_threads(void) {}
 
 static inline bool try_to_freeze_nowarn(void) { return false; }
-static inline bool try_to_freeze(void) { return false; }
+static inline bool try_to_freeze(void)
+{
+	if (current->flags & PF_KTHREAD)
+		klp_kgraft_mark_task_safe(current);
+
+	return false;
+}
 
 static inline void freezer_do_not_count(void) {}
 static inline void freezer_count(void) {}
--- a/kernel/audit_tree.c
+++ b/kernel/audit_tree.c
@@ -661,6 +661,8 @@ static int tag_mount(struct vfsmount *mn
 static int prune_tree_thread(void *unused)
 {
 	for (;;) {
+		klp_kgraft_mark_task_safe(current);
+
 		set_current_state(TASK_INTERRUPTIBLE);
 		if (list_empty(&prune_list))
 			schedule();
--- a/kernel/hung_task.c
+++ b/kernel/hung_task.c
@@ -14,6 +14,7 @@
 #include <linux/kthread.h>
 #include <linux/lockdep.h>
 #include <linux/export.h>
+#include <linux/sched.h>
 #include <linux/sysctl.h>
 #include <linux/utsname.h>
 #include <trace/events/sched.h>
@@ -229,8 +230,10 @@ static int watchdog(void *dummy)
 	for ( ; ; ) {
 		unsigned long timeout = sysctl_hung_task_timeout_secs;
 
-		while (schedule_timeout_interruptible(timeout_jiffies(timeout)))
+		while (schedule_timeout_interruptible(timeout_jiffies(timeout))) {
+			klp_kgraft_mark_task_safe(current);
 			timeout = sysctl_hung_task_timeout_secs;
+		}
 
 		if (atomic_xchg(&reset_hung_task, 0))
 			continue;
--- a/kernel/irq/manage.c
+++ b/kernel/irq/manage.c
@@ -741,6 +741,7 @@ static int irq_wait_for_interrupt(struct
 	set_current_state(TASK_INTERRUPTIBLE);
 
 	while (!kthread_should_stop()) {
+		klp_kgraft_mark_task_safe(current);
 
 		if (test_and_clear_bit(IRQTF_RUNTHREAD,
 				       &action->thread_flags)) {
--- a/kernel/kthread.c
+++ b/kernel/kthread.c
@@ -112,6 +112,8 @@ bool kthread_freezable_should_stop(bool
 {
 	bool frozen = false;
 
+	klp_kgraft_mark_task_safe(current);
+
 	might_sleep();
 
 	if (unlikely(freezing(current)))
@@ -535,6 +537,7 @@ int kthreadd(void *unused)
 		if (list_empty(&kthread_create_list))
 			schedule();
 		__set_current_state(TASK_RUNNING);
+		klp_kgraft_mark_task_safe(current);
 
 		spin_lock(&kthread_create_lock);
 		while (!list_empty(&kthread_create_list)) {
--- a/kernel/locking/locktorture.c
+++ b/kernel/locking/locktorture.c
@@ -582,6 +582,7 @@ static int lock_torture_writer(void *arg
 	set_user_nice(current, MAX_NICE);
 
 	do {
+		klp_kgraft_mark_task_safe(current);
 		if ((torture_random(&rand) & 0xfffff) == 0)
 			schedule_timeout_uninterruptible(1);
 
@@ -619,6 +620,7 @@ static int lock_torture_reader(void *arg
 	set_user_nice(current, MAX_NICE);
 
 	do {
+		klp_kgraft_mark_task_safe(current);
 		if ((torture_random(&rand) & 0xfffff) == 0)
 			schedule_timeout_uninterruptible(1);
 
@@ -721,6 +723,7 @@ static int lock_torture_stats(void *arg)
 {
 	VERBOSE_TOROUT_STRING("lock_torture_stats task started");
 	do {
+		klp_kgraft_mark_task_safe(current);
 		schedule_timeout_interruptible(stat_interval * HZ);
 		lock_torture_stats_print();
 		torture_shutdown_absorb("lock_torture_stats");
--- a/kernel/power/swap.c
+++ b/kernel/power/swap.c
@@ -577,8 +577,9 @@ static int crc32_threadfn(void *data)
 	unsigned i;
 
 	while (1) {
-		wait_event(d->go, atomic_read(&d->ready) ||
-		                  kthread_should_stop());
+		wait_event(d->go, ({ klp_kgraft_mark_task_safe(current);
+				  atomic_read(&d->ready) ||
+		                  kthread_should_stop(); }));
 		if (kthread_should_stop()) {
 			d->thr = NULL;
 			atomic_set(&d->stop, 1);
@@ -620,8 +621,9 @@ static int lzo_compress_threadfn(void *d
 	struct cmp_data *d = data;
 
 	while (1) {
-		wait_event(d->go, atomic_read(&d->ready) ||
-		                  kthread_should_stop());
+		wait_event(d->go, ({ klp_kgraft_mark_task_safe(current);
+				  atomic_read(&d->ready) ||
+		                  kthread_should_stop(); }));
 		if (kthread_should_stop()) {
 			d->thr = NULL;
 			d->ret = -1;
@@ -1112,8 +1114,9 @@ static int lzo_decompress_threadfn(void
 	struct dec_data *d = data;
 
 	while (1) {
-		wait_event(d->go, atomic_read(&d->ready) ||
-		                  kthread_should_stop());
+		wait_event(d->go, ({ klp_kgraft_mark_task_safe(current);
+				  atomic_read(&d->ready) ||
+		                  kthread_should_stop(); }));
 		if (kthread_should_stop()) {
 			d->thr = NULL;
 			d->ret = -1;
--- a/kernel/rcu/rcutorture.c
+++ b/kernel/rcu/rcutorture.c
@@ -743,6 +743,7 @@ static int rcu_torture_boost(void *arg)
 	init_rcu_head_on_stack(&rbi.rcu);
 	/* Each pass through the following loop does one boost-test cycle. */
 	do {
+		klp_kgraft_mark_task_safe(current);
 		/* Wait for the next test interval. */
 		oldstarttime = boost_starttime;
 		while (ULONG_CMP_LT(jiffies, oldstarttime)) {
@@ -798,6 +799,7 @@ checkwait:	stutter_wait("rcu_torture_boo
 
 	/* Clean up and exit. */
 	while (!kthread_should_stop() || smp_load_acquire(&rbi.inflight)) {
+		klp_kgraft_mark_task_safe(current);
 		torture_shutdown_absorb("rcu_torture_boost");
 		schedule_timeout_uninterruptible(1);
 	}
@@ -838,6 +840,7 @@ rcu_torture_cbflood(void *arg)
 	}
 	VERBOSE_TOROUT_STRING("rcu_torture_cbflood task started");
 	do {
+		klp_kgraft_mark_task_safe(current);
 		schedule_timeout_interruptible(cbflood_inter_holdoff);
 		atomic_long_inc(&n_cbfloods);
 		WARN_ON(signal_pending(current));
@@ -871,6 +874,7 @@ rcu_torture_fqs(void *arg)
 
 	VERBOSE_TOROUT_STRING("rcu_torture_fqs task started");
 	do {
+		klp_kgraft_mark_task_safe(current);
 		fqs_resume_time = jiffies + fqs_stutter * HZ;
 		while (ULONG_CMP_LT(jiffies, fqs_resume_time) &&
 		       !kthread_should_stop()) {
@@ -949,6 +953,7 @@ rcu_torture_writer(void *arg)
 	}
 
 	do {
+		klp_kgraft_mark_task_safe(current);
 		rcu_torture_writer_state = RTWS_FIXED_DELAY;
 		schedule_timeout_uninterruptible(1);
 		rp = rcu_torture_alloc();
@@ -1039,6 +1044,7 @@ rcu_torture_fakewriter(void *arg)
 	set_user_nice(current, MAX_NICE);
 
 	do {
+		klp_kgraft_mark_task_safe(current);
 		schedule_timeout_uninterruptible(1 + torture_random(&rand)%10);
 		udelay(torture_random(&rand) & 0x3ff);
 		if (cur_ops->cb_barrier != NULL &&
@@ -1160,6 +1166,7 @@ rcu_torture_reader(void *arg)
 		setup_timer_on_stack(&t, rcu_torture_timer, 0);
 
 	do {
+		klp_kgraft_mark_task_safe(current);
 		if (irqreader && cur_ops->irq_capable) {
 			if (!timer_pending(&t))
 				mod_timer(&t, jiffies + 1);
@@ -1325,6 +1332,7 @@ rcu_torture_stats(void *arg)
 {
 	VERBOSE_TOROUT_STRING("rcu_torture_stats task started");
 	do {
+		klp_kgraft_mark_task_safe(current);
 		schedule_timeout_interruptible(stat_interval * HZ);
 		rcu_torture_stats_print();
 		torture_shutdown_absorb("rcu_torture_stats");
@@ -1425,8 +1433,10 @@ static int rcu_torture_stall(void *args)
 		pr_alert("rcu_torture_stall end.\n");
 	}
 	torture_shutdown_absorb("rcu_torture_stall");
-	while (!kthread_should_stop())
+	while (!kthread_should_stop()) {
+		klp_kgraft_mark_task_safe(current);
 		schedule_timeout_interruptible(10 * HZ);
+	}
 	return 0;
 }
 
@@ -1456,10 +1466,11 @@ static int rcu_torture_barrier_cbs(void
 	VERBOSE_TOROUT_STRING("rcu_torture_barrier_cbs task started");
 	set_user_nice(current, MAX_NICE);
 	do {
-		wait_event(barrier_cbs_wq[myid],
+		wait_event(barrier_cbs_wq[myid], ({
+			   klp_kgraft_mark_task_safe(current);
 			   (newphase =
 			    smp_load_acquire(&barrier_phase)) != lastphase ||
-			   torture_must_stop());
+			   torture_must_stop(); }));
 		lastphase = newphase;
 		if (torture_must_stop())
 			break;
@@ -1491,9 +1502,10 @@ static int rcu_torture_barrier(void *arg
 		smp_store_release(&barrier_phase, !barrier_phase);
 		for (i = 0; i < n_barrier_cbs; i++)
 			wake_up(&barrier_cbs_wq[i]);
-		wait_event(barrier_wq,
+		wait_event(barrier_wq, ({
+			   klp_kgraft_mark_task_safe(current);
 			   atomic_read(&barrier_cbs_count) == 0 ||
-			   torture_must_stop());
+			   torture_must_stop(); }));
 		if (torture_must_stop())
 			break;
 		n_barrier_attempts++;
--- a/kernel/rcu/tree.c
+++ b/kernel/rcu/tree.c
@@ -2078,9 +2078,10 @@ static int __noreturn rcu_gp_kthread(voi
 					       READ_ONCE(rsp->gpnum),
 					       TPS("reqwait"));
 			rsp->gp_state = RCU_GP_WAIT_GPS;
-			wait_event_interruptible(rsp->gp_wq,
+			wait_event_interruptible(rsp->gp_wq, ({
+						 klp_kgraft_mark_task_safe(current);
 						 READ_ONCE(rsp->gp_flags) &
-						 RCU_GP_FLAG_INIT);
+						 RCU_GP_FLAG_INIT; }));
 			rsp->gp_state = RCU_GP_DONE_GPS;
 			/* Locking provides needed memory barrier. */
 			if (rcu_gp_init(rsp))
@@ -2110,6 +2111,7 @@ static int __noreturn rcu_gp_kthread(voi
 			rsp->gp_state = RCU_GP_WAIT_FQS;
 			ret = wait_event_interruptible_timeout(rsp->gp_wq,
 					rcu_gp_fqs_check_wake(rsp, &gf), j);
+			klp_kgraft_mark_task_safe(current);
 			rsp->gp_state = RCU_GP_DOING_FQS;
 			/* Locking provides needed memory barriers. */
 			/* If grace period done, leave loop. */
--- a/kernel/rcu/tree_plugin.h
+++ b/kernel/rcu/tree_plugin.h
@@ -27,6 +27,7 @@
 #include <linux/delay.h>
 #include <linux/gfp.h>
 #include <linux/oom.h>
+#include <linux/sched.h>
 #include <linux/smpboot.h>
 #include "../time/tick-internal.h"
 
@@ -1044,7 +1045,8 @@ static int rcu_boost_kthread(void *arg)
 	for (;;) {
 		rnp->boost_kthread_status = RCU_KTHREAD_WAITING;
 		trace_rcu_utilization(TPS("End boost kthread@rcu_wait"));
-		rcu_wait(rnp->boost_tasks || rnp->exp_tasks);
+		rcu_wait(({ klp_kgraft_mark_task_safe(current);
+					rnp->boost_tasks || rnp->exp_tasks; }));
 		trace_rcu_utilization(TPS("Start boost kthread@rcu_wait"));
 		rnp->boost_kthread_status = RCU_KTHREAD_RUNNING;
 		more2boost = rcu_boost(rnp);
@@ -2094,8 +2096,10 @@ wait_again:
 	/* Wait for callbacks to appear. */
 	if (!rcu_nocb_poll) {
 		trace_rcu_nocb_wake(my_rdp->rsp->name, my_rdp->cpu, "Sleep");
-		wait_event_interruptible(my_rdp->nocb_wq,
-				!READ_ONCE(my_rdp->nocb_leader_sleep));
+		wait_event_interruptible(my_rdp->nocb_wq, ({
+				klp_kgraft_mark_task_safe(current);
+				!READ_ONCE(my_rdp->nocb_leader_sleep);
+			 }));
 		/* Memory barrier handled by smp_mb() calls below and repoll. */
 	} else if (firsttime) {
 		firsttime = false; /* Don't drown trace log with "Poll"! */
@@ -2190,8 +2194,10 @@ static void nocb_follower_wait(struct rc
 		if (!rcu_nocb_poll) {
 			trace_rcu_nocb_wake(rdp->rsp->name, rdp->cpu,
 					    "FollowerSleep");
-			wait_event_interruptible(rdp->nocb_wq,
-						 READ_ONCE(rdp->nocb_follower_head));
+			wait_event_interruptible(rdp->nocb_wq, ({
+						 klp_kgraft_mark_task_safe(current);
+						 READ_ONCE(rdp->nocb_follower_head);
+					}));
 		} else if (firsttime) {
 			/* Don't drown trace log with "Poll"! */
 			firsttime = false;
@@ -2225,6 +2231,8 @@ static int rcu_nocb_kthread(void *arg)
 
 	/* Each pass through this loop invokes one batch of callbacks */
 	for (;;) {
+		klp_kgraft_mark_task_safe(current);
+
 		/* Wait for callbacks. */
 		if (rdp->nocb_leader == rdp)
 			nocb_leader_wait(rdp);
--- a/kernel/rcu/update.c
+++ b/kernel/rcu/update.c
@@ -671,8 +671,9 @@ static int __noreturn rcu_tasks_kthread(
 
 		/* If there were none, wait a bit and start over. */
 		if (!list) {
-			wait_event_interruptible(rcu_tasks_cbs_wq,
-						 rcu_tasks_cbs_head);
+			wait_event_interruptible(rcu_tasks_cbs_wq, ({
+						 klp_kgraft_mark_task_safe(current);
+						 rcu_tasks_cbs_head; }));
 			if (!rcu_tasks_cbs_head) {
 				WARN_ON(signal_pending(current));
 				schedule_timeout_interruptible(HZ/10);
--- a/kernel/smpboot.c
+++ b/kernel/smpboot.c
@@ -108,6 +108,8 @@ static int smpboot_thread_fn(void *data)
 	struct smp_hotplug_thread *ht = td->ht;
 
 	while (1) {
+		klp_kgraft_mark_task_safe(current);
+
 		set_current_state(TASK_INTERRUPTIBLE);
 		preempt_disable();
 		if (kthread_should_stop()) {
--- a/kernel/torture.c
+++ b/kernel/torture.c
@@ -105,6 +105,7 @@ torture_onoff(void *arg)
 		VERBOSE_TOROUT_STRING("torture_onoff end holdoff");
 	}
 	while (!torture_must_stop()) {
+		klp_kgraft_mark_task_safe(current);
 		cpu = (torture_random(&rand) >> 4) % (maxcpu + 1);
 		if (cpu_online(cpu) && cpu_is_hotpluggable(cpu)) {
 			if (verbose)
@@ -352,6 +353,7 @@ static int torture_shuffle(void *arg)
 {
 	VERBOSE_TOROUT_STRING("torture_shuffle task started");
 	do {
+		klp_kgraft_mark_task_safe(current);
 		schedule_timeout_interruptible(shuffle_interval);
 		torture_shuffle_tasks();
 		torture_shutdown_absorb("torture_shuffle");
@@ -430,6 +432,7 @@ static int torture_shutdown(void *arg)
 	jiffies_snap = jiffies;
 	while (ULONG_CMP_LT(jiffies_snap, shutdown_time) &&
 	       !torture_must_stop()) {
+		klp_kgraft_mark_task_safe(current);
 		delta = shutdown_time - jiffies_snap;
 		if (verbose)
 			pr_alert("%s" TORTURE_FLAG
@@ -547,6 +550,7 @@ static int torture_stutter(void *arg)
 {
 	VERBOSE_TOROUT_STRING("torture_stutter task started");
 	do {
+		klp_kgraft_mark_task_safe(current);
 		if (!torture_must_stop()) {
 			if (stutter > 1) {
 				schedule_timeout_interruptible(stutter - 1);
--- a/kernel/trace/ring_buffer.c
+++ b/kernel/trace/ring_buffer.c
@@ -4820,6 +4820,7 @@ static __init int rb_test(void *arg)
 	struct rb_test_data *data = arg;
 
 	while (!kthread_should_stop()) {
+		klp_kgraft_mark_task_safe(current);
 		rb_write_something(data, false);
 		data->cnt++;
 
@@ -4843,6 +4844,7 @@ static __init void rb_ipi(void *ignore)
 static __init int rb_hammer_test(void *arg)
 {
 	while (!kthread_should_stop()) {
+		klp_kgraft_mark_task_safe(current);
 
 		/* Send an IPI to all cpus to write data! */
 		smp_call_function(rb_ipi, NULL, 1);
--- a/kernel/trace/ring_buffer_benchmark.c
+++ b/kernel/trace/ring_buffer_benchmark.c
@@ -379,6 +379,7 @@ static void wait_to_die(void)
 static int ring_buffer_consumer_thread(void *arg)
 {
 	while (!break_test()) {
+		klp_kgraft_mark_task_safe(current);
 		complete(&read_start);
 
 		ring_buffer_consumer();
@@ -399,6 +400,7 @@ static int ring_buffer_consumer_thread(v
 static int ring_buffer_producer_thread(void *arg)
 {
 	while (!break_test()) {
+		klp_kgraft_mark_task_safe(current);
 		ring_buffer_reset(buffer);
 
 		if (consumer) {
--- a/kernel/trace/trace_benchmark.c
+++ b/kernel/trace/trace_benchmark.c
@@ -147,6 +147,7 @@ static int benchmark_event_kthread(void
 	msleep(100);
 
 	while (!kthread_should_stop()) {
+		klp_kgraft_mark_task_safe(current);
 
 		trace_do_benchmark();
 
--- a/kernel/trace/trace_events.c
+++ b/kernel/trace/trace_events.c
@@ -3224,6 +3224,7 @@ static __init int event_test_thread(void
 
 	set_current_state(TASK_INTERRUPTIBLE);
 	while (!kthread_should_stop()) {
+		klp_kgraft_mark_task_safe(current);
 		schedule();
 		set_current_state(TASK_INTERRUPTIBLE);
 	}
--- a/kernel/trace/trace_selftest.c
+++ b/kernel/trace/trace_selftest.c
@@ -1064,6 +1064,7 @@ static int trace_wakeup_test_thread(void
 
 	/* we are awake, now wait to disappear */
 	while (!kthread_should_stop()) {
+		klp_kgraft_mark_task_safe(current);
 		schedule();
 		set_current_state(TASK_INTERRUPTIBLE);
 	}
--- a/kernel/workqueue.c
+++ b/kernel/workqueue.c
@@ -2292,6 +2292,7 @@ sleep:
 	__set_current_state(TASK_INTERRUPTIBLE);
 	spin_unlock_irq(&pool->lock);
 	schedule();
+	klp_kgraft_mark_task_safe(current);
 	goto woke_up;
 }
 
@@ -2333,6 +2334,8 @@ static int rescuer_thread(void *__rescue
 repeat:
 	set_current_state(TASK_INTERRUPTIBLE);
 
+	klp_kgraft_mark_task_safe(current);
+
 	/*
 	 * By the time the rescuer is requested to stop, the workqueue
 	 * shouldn't have any work pending, but @wq->maydays may still have
--- a/mm/huge_memory.c
+++ b/mm/huge_memory.c
@@ -2951,6 +2951,7 @@ static void khugepaged_do_scan(void)
 			break;
 
 		cond_resched();
+		klp_kgraft_mark_task_safe(current);
 
 		if (unlikely(kthread_should_stop() || try_to_freeze()))
 			break;
@@ -2977,14 +2978,17 @@ static void khugepaged_wait_work(void)
 		if (!khugepaged_scan_sleep_millisecs)
 			return;
 
-		wait_event_freezable_timeout(khugepaged_wait,
-					     kthread_should_stop(),
+		wait_event_freezable_timeout(khugepaged_wait, ({
+					klp_kgraft_mark_task_safe(current);
+					     kthread_should_stop(); }),
 			msecs_to_jiffies(khugepaged_scan_sleep_millisecs));
 		return;
 	}
 
 	if (khugepaged_enabled())
-		wait_event_freezable(khugepaged_wait, khugepaged_wait_event());
+		wait_event_freezable(khugepaged_wait, ({
+					klp_kgraft_mark_task_safe(current);
+					khugepaged_wait_event(); }));
 }
 
 static int khugepaged(void *none)
--- a/mm/kmemleak.c
+++ b/mm/kmemleak.c
@@ -1492,6 +1492,8 @@ static int kmemleak_scan_thread(void *ar
 	while (!kthread_should_stop()) {
 		signed long timeout = jiffies_scan_wait;
 
+		klp_kgraft_mark_task_safe(current);
+
 		mutex_lock(&scan_mutex);
 		kmemleak_scan();
 		mutex_unlock(&scan_mutex);
--- a/mm/ksm.c
+++ b/mm/ksm.c
@@ -1748,8 +1748,9 @@ static int ksm_scan_thread(void *nothing
 			schedule_timeout_interruptible(
 				msecs_to_jiffies(ksm_thread_sleep_millisecs));
 		} else {
-			wait_event_freezable(ksm_thread_wait,
-				ksmd_should_run() || kthread_should_stop());
+			wait_event_freezable(ksm_thread_wait, ({
+				klp_kgraft_mark_task_safe(current);
+				ksmd_should_run() || kthread_should_stop(); }));
 		}
 	}
 	return 0;
--- a/net/bluetooth/bnep/core.c
+++ b/net/bluetooth/bnep/core.c
@@ -493,6 +493,7 @@ static int bnep_session(void *arg)
 	init_waitqueue_entry(&wait, current);
 	add_wait_queue(sk_sleep(sk), &wait);
 	while (1) {
+		klp_kgraft_mark_task_safe(current);
 		set_current_state(TASK_INTERRUPTIBLE);
 
 		if (atomic_read(&s->terminate))
--- a/net/bluetooth/cmtp/core.c
+++ b/net/bluetooth/cmtp/core.c
@@ -290,6 +290,7 @@ static int cmtp_session(void *arg)
 	init_waitqueue_entry(&wait, current);
 	add_wait_queue(sk_sleep(sk), &wait);
 	while (1) {
+		klp_kgraft_mark_task_safe(current);
 		set_current_state(TASK_INTERRUPTIBLE);
 
 		if (atomic_read(&session->terminate))
--- a/net/bluetooth/hidp/core.c
+++ b/net/bluetooth/hidp/core.c
@@ -1182,6 +1182,7 @@ static void hidp_session_run(struct hidp
 	struct sk_buff *skb;
 
 	for (;;) {
+		klp_kgraft_mark_task_safe(current);
 		/*
 		 * This thread can be woken up two ways:
 		 *  - You call hidp_session_terminate() which sets the
--- a/net/bluetooth/rfcomm/core.c
+++ b/net/bluetooth/rfcomm/core.c
@@ -2098,6 +2098,8 @@ static int rfcomm_run(void *unused)
 	add_wait_queue(&rfcomm_wq, &wait);
 	while (!kthread_should_stop()) {
 
+		klp_kgraft_mark_task_safe(current);
+
 		/* Process stuff */
 		rfcomm_process_sessions();
 
--- a/net/netfilter/ipvs/ip_vs_sync.c
+++ b/net/netfilter/ipvs/ip_vs_sync.c
@@ -1693,6 +1693,7 @@ static int sync_thread_master(void *data
 		ipvs->mcfg.mcast_ifn, ipvs->mcfg.syncid, tinfo->id);
 
 	for (;;) {
+		klp_kgraft_mark_task_safe(current);
 		sb = next_sync_buff(ipvs, ms);
 		if (unlikely(kthread_should_stop()))
 			break;
@@ -1704,9 +1705,10 @@ static int sync_thread_master(void *data
 			/* (Ab)use interruptible sleep to avoid increasing
 			 * the load avg.
 			 */
-			__wait_event_interruptible(*sk_sleep(sk),
+			__wait_event_interruptible(*sk_sleep(sk), ({
+						   klp_kgraft_mark_task_safe(current);
 						   sock_writeable(sk) ||
-						   kthread_should_stop());
+						   kthread_should_stop(); }));
 			if (unlikely(kthread_should_stop()))
 				goto done;
 		}
@@ -1747,9 +1749,10 @@ static int sync_thread_backup(void *data
 		ipvs->bcfg.mcast_ifn, ipvs->bcfg.syncid, tinfo->id);
 
 	while (!kthread_should_stop()) {
-		wait_event_interruptible(*sk_sleep(tinfo->sock->sk),
+		wait_event_interruptible(*sk_sleep(tinfo->sock->sk), ({
+			 klp_kgraft_mark_task_safe(current);
 			 !skb_queue_empty(&tinfo->sock->sk->sk_receive_queue)
-			 || kthread_should_stop());
+			 || kthread_should_stop(); }));
 
 		/* do we have data now? */
 		while (!skb_queue_empty(&(tinfo->sock->sk->sk_receive_queue))) {
--- a/samples/trace_events/trace-events-sample.c
+++ b/samples/trace_events/trace-events-sample.c
@@ -24,6 +24,7 @@ static void simple_thread_func(int cnt)
 	int len = cnt % 5;
 	int i;
 
+	klp_kgraft_mark_task_safe(current);
 	set_current_state(TASK_INTERRUPTIBLE);
 	schedule_timeout(HZ);
 
--- a/sound/pci/emu10k1/emu10k1_main.c
+++ b/sound/pci/emu10k1/emu10k1_main.c
@@ -716,6 +716,7 @@ static int emu1010_firmware_thread(void
 	int err;
 
 	for (;;) {
+		klp_kgraft_mark_task_safe(current);
 		/* Delay to allow Audio Dock to settle */
 		msleep_interruptible(1000);
 		if (kthread_should_stop())
